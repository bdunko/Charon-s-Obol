[gd_scene load_steps=97 format=3 uid="uid://btdousdmcb6d3"]

[ext_resource type="Script" path="res://game.gd" id="1_2km4d"]
[ext_resource type="Material" uid="uid://cv6rp2tdke6lb" path="res://shaders/purple_check.tres" id="2_82tsr"]
[ext_resource type="Script" path="res://ui/river.gd" id="3_icqna"]
[ext_resource type="Material" uid="uid://cbfa6d74evufb" path="res://assets/table/river_shader.tres" id="3_lg24x"]
[ext_resource type="Texture2D" uid="uid://sr30u1imc127" path="res://assets/table/table.png" id="3_uvdwv"]
[ext_resource type="Texture2D" uid="uid://b08n3j31id5vm" path="res://assets/table/river_purple.png" id="4_hxf6a"]
[ext_resource type="PackedScene" uid="uid://cr6fktifdg2pi" path="res://ui/dialogue_system.tscn" id="4_sixhk"]
[ext_resource type="Script" path="res://player_textboxes.gd" id="5_6g64w"]
[ext_resource type="PackedScene" uid="uid://bedblkbwue803" path="res://ui/textbox.tscn" id="5_703wq"]
[ext_resource type="Texture2D" uid="uid://buds51eoanr08" path="res://assets/table/river_green.png" id="6_df67t"]
[ext_resource type="PackedScene" uid="uid://d1vri2m1wvvey" path="res://shaders/fx.tscn" id="6_gfndp"]
[ext_resource type="Script" path="res://ui/flip_button.gd" id="6_rf73a"]
[ext_resource type="Script" path="res://ui/accept_button.gd" id="7_2acd8"]
[ext_resource type="Script" path="res://shaders/fx.gd" id="7_4br5g"]
[ext_resource type="Texture2D" uid="uid://c83k55kmpa2b4" path="res://assets/table/river_red.png" id="7_5tpvh"]
[ext_resource type="Shader" path="res://shaders/shader.gdshader" id="7_aonp5"]
[ext_resource type="Script" path="res://ui/shop_continue_button.gd" id="8_leu43"]
[ext_resource type="Script" path="res://ui/shop_reroll_button.gd" id="9_cd2hg"]
[ext_resource type="Script" path="res://ui/end_round_button.gd" id="9_d50av"]
[ext_resource type="Script" path="res://ui/die_button.gd" id="10_oe7lm"]
[ext_resource type="Script" path="res://ui/pay_toll_button.gd" id="11_mcnia"]
[ext_resource type="Script" path="res://ui/voyage_map/voyage_continue_button.gd" id="12_dxqog"]
[ext_resource type="Script" path="res://ui/board_button.gd" id="13_6rw3p"]
[ext_resource type="FontFile" uid="uid://dgfoet7uiqnul" path="res://assets/fonts/alagard.ttf" id="14_om374"]
[ext_resource type="Script" path="res://ui/flame_label.gd" id="15_nixm5"]
[ext_resource type="Script" path="res://ui/lives_label.gd" id="15_wj7tb"]
[ext_resource type="Script" path="res://ui/tooltip_emitter.gd" id="16_1vi63"]
[ext_resource type="PackedScene" uid="uid://cmc1jbioa2xwp" path="res://components/charon_hand.tscn" id="16_32esb"]
[ext_resource type="Script" path="res://ui/fragments_label.gd" id="16_ee6yk"]
[ext_resource type="Script" path="res://ui/shop_mat.gd" id="16_i4s2h"]
[ext_resource type="Script" path="res://ui/ignite_label.gd" id="17_msny5"]
[ext_resource type="PackedScene" uid="uid://dgds4d2p6hdb6" path="res://ui/voyage_map/voyage_map.tscn" id="18_vo2di"]
[ext_resource type="PackedScene" uid="uid://kw0850n3cqvo" path="res://components/coin_row.tscn" id="19_ym3ga"]
[ext_resource type="Script" path="res://ui/shop.gd" id="20_xqqdj"]
[ext_resource type="Texture2D" uid="uid://cdmwcxsmmcl4n" path="res://assets/table/shop_mat.png" id="21_brubq"]
[ext_resource type="Script" path="res://enemy_row.gd" id="24_cds23"]
[ext_resource type="PackedScene" uid="uid://bcwxsw4cf46jj" path="res://components/patron_tokens/zeus.tscn" id="24_k7xdm"]
[ext_resource type="Script" path="res://speedrun_timer.gd" id="34_5jlkt"]
[ext_resource type="Texture2D" uid="uid://0ycixrey3lc3" path="res://assets/particles/hollow_spike.png" id="36_l5qg4"]
[ext_resource type="Texture2D" uid="uid://c3kmtpo1q45xo" path="res://assets/particles/circle.png" id="36_lon5y"]
[ext_resource type="Script" path="res://game_info_view.gd" id="39_25ek7"]

[sub_resource type="Shader" id="Shader_yc8jt"]
code = "// Ben's Uber Pixel Shader
// WARNING - Shader expects uniform inputs in the range 0.0 - 1.0 for Colors. 
//           Therefore, be sure that Colors being passed in are in the correct range of (0-1, 0-1, 0-1, 0-1).
shader_type canvas_item;

// --- Utilty Functions --- //
const bool DEBUG = true;
const float TIME_OFFSET = 10.0; //offset all start times by this... for some reason things line up better with expectations
const vec2 HORIZONTAL_VERTICAL_OFFSETS[4] = {vec2(0, 1), vec2(-1, 0), vec2(1, 0), vec2(0, -1)};
const vec2 DIAGONAL_OUTLINE_OFFSETS[4] = {vec2(1, 1), vec2(-1, 1), vec2(1, -1), vec2(-1, -1)};

// checks if two values are 'equal' (within EPSILON of each other)
// necessary when doing float calculations since it's not perfectly precise
const float EPSILON = 0.001;
bool floateq(float val1, float val2) { return val1 >= val2 - EPSILON && val1 <= val2 + EPSILON; }
bool vec3eq(vec3 val1, vec3 val2) { return floateq(val1.r, val2.r) && floateq(val1.g, val2.g) && floateq(val1.b, val2.b); }

// Author: Michael Pohoreski https://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader
float random(vec2 seed){ return fract(cos(dot(seed, vec2(23.14069263277926, 2.665144142690225))) * 12345.6789); }
float snoise3(vec2 seed) { return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453); }
float randf_range(vec2 seed, float b1, float b2) { return mix(b1, b2, random(seed)); }
int randi_range(vec2 seed, int b1, int b2) { return int(randf_range(seed, float(b1), float(b2))); }
float sin0to1(float time) { return (sin(time)+1.0)/2.0; }
float cos0to1(float time) { return (cos(time)+1.0)/2.0; } 
float vary0to1(float time) { return 1.0-(cos(time)+1.0)/2.0; } // a transformed cos function that varies from 0 to 1. f(0) = 0, f(pi) = 1, f(2pi) = 0. 

uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;

uniform bool POST_PROCESSING = false;

// pass in the mouse position here
uniform vec2 MOUSE = vec2(20, 20);


// --- Effects --- //
// EXCLUDE
// If use_exclude_colors, pixels of these colors are excluded from tint, color correction, scanline, and vignette effects.
group_uniforms Exclude;
uniform bool use_exclude_colors = true;
uniform vec3 exclude_color1: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color2: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color3: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color4: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders

// PAN/DISPLACE
// Displaces all pixels by (displace_x, displace_y). Texture repeats if displace_repeat.
// WARNING - Offsetting beyond the bounds of the texture will result in the texture being cut off
group_uniforms PanAndDisplacement;
uniform int displace_x = 0;
uniform int displace_y = 0;
uniform bool displace_repeat = true;
// Texture will automatically scroll if auto_pan_speed is nonzero.
// Set auto_pan_speed to a positive number for left/up panning; negative number for right/down panning
// WARNING - Repeat generally should be true for auto_pan_speed, otherwise it will immediately pan out of view
uniform vec2 auto_pan_speed = vec2(0, 0);

// RECOLOR
// Replaces replace_colorN with replace_with_colorN.
group_uniforms Recolor;
uniform vec3 replace_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color5: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color5: source_color = vec3(0.0, 0.0, 0.0);

// special extra uniform specifically intended to recolor outlines
uniform vec3 replace_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 replace_with_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392);

// TINT
// Tint the texture with tint_color.
// The strength of the tint is controlled by tint_strength.
group_uniforms Tint;
uniform vec3 tint_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float tint_strength: hint_range(0.0, 1.0) = 0.0;

// FLASH
// Flash the texture with flash_color. Essentially, this is a second layer of tint.
// flash_strength controls how much color is the original and how much is the flash_color.
group_uniforms Flash;
uniform vec3 flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float flash_strength: hint_range(0.0, 1.0) = 0.0;
// auto_flash_speed will cause infinite and repeated flashing in auto_flash_color if nonzero and controls the speed of this flashing.
// auto_flash_bound1 and auto_flash_bound2 provide the bounds of the flashing effect.
// To prevent the auto flash from starting in the middle of the animation, set auto_flash_start_time to the global time when enabling auto flash.
// TIP - auto flash and regular ('manual') flash stack, which is why they have two separate colors.
uniform vec3 auto_flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float auto_flash_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flash_bound1: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flash_bound2: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flash_start_time = 0.0;

// COLOR CORRECTION
group_uniforms ColorCorrection;
// Applies red, green, or blue color correction with red_correct, green_correct, and blue_correct. 
// Applies grayscale with gray_correct.
// Modify brightness, contrast, or saturation with brightness_correct, contrast_correct, and saturation_correct.
// TIP - these values can actually go higher or lower, if you want a more extreme effect
uniform float red_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float green_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float blue_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float gray_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float brightness_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float contrast_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float saturation_correct: hint_range(0.0, 2.0, 0.01) = 1.0;

// TODO - more funky color options
// rg swap - swaps the original (before any other swaps) value of r and g
// gb swap
// br swap
// r_eq_g - sets r = g
// r_eq_b
// g_eq_r
// g_eq_b
// b_eq_r
// b_eq_g

// TODO - ROUGHEN - applies randomized brightness modifications across the texture (both positive and negative) to 'roughen' it up

// SCANLINES
// Create a line across the canvas of scanline_color. scanline_strength controls the alpha of the line.
// Define the position of the line with scanline_left_to_right_position, scanline_top_to_bottom_position,
// scanline_topleft_to_bottomright_position, and scanline_topright_to_bottomleft_position.
// The line is vertical if going left to right, horizontal if going top to bottom, and diagonal for the other two.
group_uniforms Scanline;
uniform vec3 scanline_color: source_color = vec3(0.98, 0.69, 0.23);
uniform float scanline_strength: hint_range(0.0, 1.0, 0.01) = 1.0;
uniform float scanline_left_to_right_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_top_to_bottom_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topleft_to_bottomright_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topright_to_bottomleft_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
// auto_scanline_DIRECTION_on will enable automatic repeating scanlines in that direction.
// auto_scanline_DIRECTION_reverse will flip the direction.
// The scan will be visible for auto_scanline_DIRECTION_scan_duration, with a delay of 
// auto_scanline_DIRECTION_scan_duration before the next scan begins.
// To prevent the scanline from starting in the middle of the texture, provide the global time to auto_scanline_DIRECTION_start_time.
uniform bool auto_scanline_left_to_right_on = false;
uniform bool auto_scanline_left_to_right_reverse = false;
uniform float auto_scanline_left_to_right_start_time = 0.0;
uniform float auto_scanline_left_to_right_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_left_to_right_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_top_to_bottom_on = false;
uniform bool auto_scanline_top_to_bottom_reverse = false;
uniform float auto_scanline_top_to_bottom_start_time = 0.0;
uniform float auto_scanline_top_to_bottom_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_top_to_bottom_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topleft_to_bottomright_on = false;
uniform bool auto_scanline_topleft_to_bottomright_reverse = false;
uniform float auto_scanline_topleft_to_bottomright_start_time = 0.0;
uniform float auto_scanline_topleft_to_bottomright_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topleft_to_bottomright_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topright_to_bottomleft_on = false;
uniform bool auto_scanline_topright_to_bottomleft_reverse = false;
uniform float auto_scanline_topright_to_bottomleft_start_time = 0.0;
uniform float auto_scanline_topright_to_bottomleft_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topright_to_bottomleft_delay: hint_range(0.0, 10.0, 0.01) = 1.0;

// OUTLINE
// Adds a pixel outline to the texture, with glow_color and glow_thickness.
// glow_dialgonals controls if we also create this outline diagonally, which makes it thicker.
// This can be used to create a solid outline if auto_glow_speed is left at 0.
// WARNING - Shaders cannot draw outside of the bounds of the canvas, so the canvas may need extra transparent space on the sides.
// WARNING - Can have some odd effects with sprites containing partial transparency.
group_uniforms GlowAndOutline;
uniform vec4 glow_color: source_color = vec4(1.0);
uniform int glow_thickness: hint_range(0, 10) = 0;
uniform bool glow_diagonals = false;
// auto_glow_speed defines the speed of a glow fluctuating alpha between the outline's alpha and auto_glow_bound at auto_glow_speed.
// To prevent the auto glow from starting in the middle of the animation, set auto_glow_start_time to the global time when enabling auto glow.
uniform float auto_glow_speed: hint_range(0.0, 30.0) = 0.0;
uniform float auto_glow_bound: hint_range(0.0, 1.0) = 0.75;
uniform float auto_glow_start_time = 0.0;

// DISINTEGRATE
// Sets 'random' pixels in the canvas to disintegrate_color with alpha between disintegrate_alpha_bound1 and disintegrate_alpha_bound2.
// By default, since these bounds are 0, the pixels will be made fully transparent and therefore disintegrate_color is unused.
// disintegrate_strength controls the amount of pixels affected, from none (0) to all of them (1).
// Change the pattern via disintegrate_seed.
// disintegrate_as_static changes the purpose of disintegrate to not affect the alpha of the texture.
// Instead, it layers a static-looking pattern on top using disintegrate_color, where the color is based on disintegrate_color
// and the alpha of the static pattern ranges randomly between disintegrate_alpha_bound1 and disintegrate_alpha_bound2 per pixel.
// Note that with the default bounds of 0 and 0, this setting creates no effect whatsoever.
// If auto_disintegrate_random_seed_speed is nonzero, applies randomization to the seed over time based on speed.
// In this case, disintegrate_seed has no effect.
group_uniforms Disintegrate;
uniform int disintegrate_seed = 1;
uniform vec3 disintegrate_color : source_color = vec3(0.0, 0.0, 0.0);
uniform float disintegrate_strength: hint_range(0.0, 1.0) = 0.0;
uniform float disintegrate_alpha_bound1 = 0.0;
uniform float disintegrate_alpha_bound2 = 0.0;
uniform bool disintegrate_as_static = false;
uniform float auto_disintegrate_random_seed_speed: hint_range(0.0, 1.0) = 0.0;

// FOG
// Applies a fog_noise_texture filter over the texture with modifiable fog_opacity and fog_density, moving at fog_speed
// Mostly used to create fog effects by assigning to a ColorRect (color is changable by changing ColorRect color too!)
// NOTE - Don't use this as a post processing shader. 
group_uniforms Fog;
uniform bool fog_enabled = false;
uniform sampler2D fog_noise_texture: repeat_enable, filter_nearest;
uniform float fog_opacity: hint_range(0.0, 1.0) = 0.5;
uniform float fog_density: hint_range(0.0, 1.0) = 0.25;
uniform vec2 fog_speed = vec2(-0.02, 0.0);

// COLORLINES
// Creates vertical/horizontal lines of colorline_color spaced colorline_spacing pixels apart 
// with colorline_strength alpha across the texture.
group_uniforms Colorlines;
uniform vec3 vertical_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int vertical_colorline_spacing = 2;
uniform float vertical_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;
uniform vec3 horizontal_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int horizontal_colorline_spacing = 2;
uniform float horizontal_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;

// CHECKER
// Creates a checkerboard pattern across the texture of checker_color with checker_strength alpha.
// checker_x_size and checker_y_size defines the size of each rectangular checker
// checker_x_pattern and checker_y_pattern affect the pattern of the checker pattern (which
// can stop looking checkered with different values).
// checker_contrast_amount applies a darkening effect to pixels of the checkerboard that are already dark.
// checker_contrast_ratio increases the contrast of the darkening effect between light and dark colored pixels,
// ie dark pixels become even darker.
group_uniforms CHECKER;
uniform vec3 checker_color: source_color = vec3(0.2, 0.2, 0.2);
uniform float checker_strength: hint_range(0.0, 1.0, 0.01) = 0.0; //0.3 is a good one
uniform int checker_x_size: hint_range(1, 64, 1) = 1;
uniform int checker_y_size: hint_range(1, 64, 1) = 1;
uniform int checker_x_pattern: hint_range(1, 32, 1) = 2;
uniform int checker_y_pattern: hint_range(1, 32, 1) = 2;
uniform float checker_contrast_amount: hint_range(-10.0, 10.0, 0.1) = 1.0;
uniform float checker_contrast_ratio: hint_range(0.0, 10.0, 0.01) = 0.5;
// TODO - experiment a bit more with the contrast calculation here - maybe subtract 0.5 and LIGHTEN lighter areas?

// MOUSELIGHT
// Creates a circular lighting effect at the mouse's position if mouselight_on, of mouselight_color and mouselight_strength alpha.
// Mouselight size defines the radius of the light effect.
// If mouselight_soften_edges, pixels further from the center of the light are more transparent.
// If mouselight_checker, the effect will be checkered in a way that interacts with the CHECKER effect.
// If auto_mouselight_flicker_speed is non-zero, the light will oscillate in size between mouselight_size and auto_mouselight_flicker_speed
group_uniforms Mouselight;
uniform bool mouselight_on = false;
uniform vec3 mouselight_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float mouselight_strength = 0.5;
uniform int mouselight_size = 8;
uniform bool mouselight_soften_edges = true;
uniform bool mouselight_checker = false;
uniform float auto_mouselight_flicker_speed: hint_range(0.0, 20.0) = 8;
uniform float auto_mouselight_flicker_bound = 10;

// CUT
// Cuts off all pixels of the texture from left/right/top/bottom.
group_uniforms Cut;
uniform float cut_left: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_right: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_top: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_bottom: hint_range(0.0, 1.0, 0.001) = 0.0;

// VIGNETTE
// Applies a circular vignette effect on the canvas if vignette_on.
// The vignette has a vignette_radius and a vignette_color.
// If vignette_ignore_transparent, transparent pixels will not have the vignette applied.
// This is generally useful if you want to apply a vignette on something besides the entire screen.
// Radius -> 0 tends to do some crazy effects
group_uniforms Vignette;
uniform bool vignette_on = false;
uniform bool vignette_ignore_transparent = false;
uniform vec3 vignette_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float vignette_radius: hint_range(0.001, 20.0, 0.01) = 1.0;

// TRANSPARENCY
// Controls transparency of the texture.
// If auto_flicker_speed is not zero, oscillates between transparency and auto_flicker_bounds at auto_flicker_speed.
// To prevent the auto flicker from starting in the middle of the animation, set auto_flicker_start_time to the global time when enabling auto flicker.
group_uniforms Transparency;
uniform float transparency: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flicker_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flicker_bound: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flicker_start_time = 0.0;

// --- Fragment Shader --- //
void fragment() 
{
	COLOR = texture(TEXTURE, UV);
	
	// --- CALCULATE CONSTANTS ---
	// WARNING - Don't use the ones with _ directly. 
	// the size of this canvas in pixels (ex 10x10)
	int _SIZE_IN_PIXELS_X = int(floor(1.0 / TEXTURE_PIXEL_SIZE.x));
	int _SIZE_IN_PIXELS_Y = int(floor(1.0 / TEXTURE_PIXEL_SIZE.y));
	// the size of the screen in pixels (ex 320x180)
	int _SCREEN_SIZE_IN_PIXELS_X = int(floor(1.0 / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_SIZE_IN_PIXELS_Y = int(floor(1.0 / SCREEN_PIXEL_SIZE.y));
	
	// the specific x and y pixel coordinates within texture
	int _PIXEL_X = int(floor(UV.x / TEXTURE_PIXEL_SIZE.x));
	int _PIXEL_Y = int(floor(UV.y / TEXTURE_PIXEL_SIZE.y));
	// the specific x and y pixel coordinates within screen
	int _SCREEN_PIXEL_X = int(floor(SCREEN_UV.x / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_PIXEL_Y = int(floor(SCREEN_UV.y / SCREEN_PIXEL_SIZE.y));
	
	// WARNING - Use these instead. This accounts for if this is a normal or post processing shader.
	// Size of a pixel for this canvas (ie 1/320x1/180)
	float PIXEL_SIZE_X = POST_PROCESSING ? SCREEN_PIXEL_SIZE.x : TEXTURE_PIXEL_SIZE.x;
	float PIXEL_SIZE_Y = POST_PROCESSING ? SCREEN_PIXEL_SIZE.y : TEXTURE_PIXEL_SIZE.y;
	// Size of the canvas in pixels. (ex 320x180)
	int SIZE_IN_PIXELS_X = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_X : _SIZE_IN_PIXELS_X;
	int SIZE_IN_PIXELS_Y = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_Y : _SIZE_IN_PIXELS_Y;
	// The specific XY coordinates of the current pixel.
	int X = POST_PROCESSING ? _SCREEN_PIXEL_X : _PIXEL_X;
	int Y = POST_PROCESSING ? _SCREEN_PIXEL_Y : _PIXEL_Y;
	// UV coordinates of the current pixel.
	vec2 MUV = POST_PROCESSING ? SCREEN_UV : UV;
	// ---
	
	
	// DISPLACE & PAN
	vec2 adjUV = vec2(0, 0); // WARNING - Use this instead of UV below, otherwise effects break with panning & displace
	
	float displaceUVX = MUV.x + (SCREEN_PIXEL_SIZE.x * float(displace_x));
	float displaceUVY = MUV.y + (SCREEN_PIXEL_SIZE.y * float(displace_y));
	if (displace_repeat) {
		adjUV = mod(vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed, 1.00000);
	} else {
		adjUV = vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed;
	}
	
	// $HACK$ doing this as a ternary breaks the preview, for some reason
	if (POST_PROCESSING) 
		COLOR = texture(SCREEN_TEXTURE, adjUV);
	else 
		COLOR = texture(TEXTURE, adjUV);
	
	// EXCLUDE COLORS
	bool is_exclude_color = use_exclude_colors && (vec3eq(COLOR.rgb, exclude_color1) || vec3eq(COLOR.rgb, exclude_color2) || vec3eq(COLOR.rgb, exclude_color3) || vec3eq(COLOR.rgb, exclude_color4));
	
	// RECOLOR
	if (vec3eq(COLOR.rgb, replace_color1)) 
		COLOR.rgb = replace_with_color1;
	if (vec3eq(COLOR.rgb, replace_color2)) 
		COLOR.rgb = replace_with_color2;
	if (vec3eq(COLOR.rgb, replace_color3)) 
		COLOR.rgb = replace_with_color3;
	if (vec3eq(COLOR.rgb, replace_color4)) 
		COLOR.rgb = replace_with_color4;
	if (vec3eq(COLOR.rgb, replace_color5)) 
		COLOR.rgb = replace_with_color5;
	if (vec3eq(COLOR.rgb, replace_color_outline))
		COLOR.rgb = replace_with_color_outline;
	
	// TINT, COLOR CORRECTION, and SCANLINE ignore excluded colors
	if (!is_exclude_color) {
		// TINT
		COLOR.rgb = mix(COLOR.rgb, tint_color, tint_strength);

		// FLASH
		// apply automatic flash
		if (auto_flash_speed != 0.0) {
			float auto_strength = mix(auto_flash_bound1, auto_flash_bound2, abs(vary0to1((TIME-auto_flash_start_time + TIME_OFFSET) * auto_flash_speed)));
			COLOR.rgb = mix(COLOR.rgb, auto_flash_color, auto_strength);
		}
		// apply manual flash
		COLOR.rgb = mix(COLOR.rgb, flash_color, flash_strength);

		// COLOR CORRECTION
		COLOR.r = mix(COLOR.r, 1.0, red_correct);
		COLOR.g = mix(COLOR.g, 1.0, green_correct);
		COLOR.b = mix(COLOR.b, 1.0, blue_correct);
		COLOR.rgb = mix(COLOR.rgb, vec3(0.2126 * COLOR.r + 0.7152 * COLOR.g + 0.0722 * COLOR.b), gray_correct);
		COLOR.rgb = mix(vec3(0.0), COLOR.rgb, brightness_correct);
		COLOR.rgb = mix(vec3(0.5), COLOR.rgb, contrast_correct);
		COLOR.rgb = mix(vec3(dot(vec3(1.0), COLOR.rbg)), COLOR.rgb, saturation_correct);

		// SCANLINE
		// FIX
		if (COLOR.a != 0.0) {
			float l_to_r_pos = !auto_scanline_left_to_right_on ? scanline_left_to_right_position : abs((auto_scanline_left_to_right_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_left_to_right_start_time + TIME_OFFSET, auto_scanline_left_to_right_delay + auto_scanline_left_to_right_scan_duration), 0.0, auto_scanline_left_to_right_scan_duration)/auto_scanline_left_to_right_scan_duration)));
			float t_to_b_pos = !auto_scanline_top_to_bottom_on ? scanline_top_to_bottom_position : abs((auto_scanline_top_to_bottom_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_top_to_bottom_start_time + TIME_OFFSET, auto_scanline_top_to_bottom_delay + auto_scanline_top_to_bottom_scan_duration), 0.0, auto_scanline_top_to_bottom_scan_duration)/auto_scanline_top_to_bottom_scan_duration)));
			float tl_to_br_pos = !auto_scanline_topleft_to_bottomright_on ? scanline_topleft_to_bottomright_position : abs((auto_scanline_topleft_to_bottomright_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topleft_to_bottomright_start_time + TIME_OFFSET, auto_scanline_topleft_to_bottomright_delay + auto_scanline_topleft_to_bottomright_scan_duration), 0.0, auto_scanline_topleft_to_bottomright_scan_duration)/auto_scanline_topleft_to_bottomright_scan_duration)));
			float tr_to_bl_pos = !auto_scanline_topright_to_bottomleft_on ? scanline_topright_to_bottomleft_position : abs((auto_scanline_topright_to_bottomleft_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topright_to_bottomleft_start_time + TIME_OFFSET, auto_scanline_topright_to_bottomleft_delay + auto_scanline_topright_to_bottomleft_scan_duration), 0.0, auto_scanline_topright_to_bottomleft_scan_duration)/auto_scanline_topright_to_bottomleft_scan_duration)));

			if (X == int(floor(l_to_r_pos / float(PIXEL_SIZE_X))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (Y == int(floor(t_to_b_pos / float(PIXEL_SIZE_Y))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			int scanline_target_tlbr = int(floor(tl_to_br_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y)));
			int scanline_target_trbl = int(floor(tr_to_bl_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y))) - SIZE_IN_PIXELS_Y;
			if (X+Y == scanline_target_tlbr)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (X-Y == scanline_target_trbl)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
		}
	}

	// GLOW
	if (glow_thickness != 0) {
		vec2 outline_size = TEXTURE_PIXEL_SIZE * float(glow_thickness);
		float outline = 0.0;
		for (int i = 0; i < HORIZONTAL_VERTICAL_OFFSETS.length(); i++) {
			outline += texture(TEXTURE, adjUV + outline_size * HORIZONTAL_VERTICAL_OFFSETS[i]).a;
		}
		if (glow_diagonals) {
			for (int i = 0; i < DIAGONAL_OUTLINE_OFFSETS.length(); i++) {
				outline += texture(TEXTURE, adjUV + outline_size * DIAGONAL_OUTLINE_OFFSETS[i]).a;
			}
		}
		outline = min(outline, 1.0);
		// this is a bit of a coding $HACK$ to make auto_glow_bound do nothing if auto_glow_speed is 0, but it definitely works
		float alp = auto_glow_speed == 0.0 ? 1.0 : mix(auto_glow_bound, glow_color.a, vary0to1((TIME - auto_glow_start_time + TIME_OFFSET) * auto_glow_speed));
		COLOR = mix(COLOR, glow_color * alp, outline - COLOR.a);
	}

	// DISINTEGRATE
	if (!is_exclude_color && COLOR.a != 0.0) {
		vec2 s = adjUV * vec2(float(disintegrate_seed));
		s *= auto_disintegrate_random_seed_speed != 0.0 ? float(int(TIME / mix(1.0, 0.001, auto_disintegrate_random_seed_speed))) : 1.0;
		float r = random(s);
		if (r < disintegrate_strength) {
			float r_alpha = randf_range(s, disintegrate_alpha_bound1, disintegrate_alpha_bound2);
			COLOR.rgb = mix(COLOR.rgb, disintegrate_color, r_alpha);
			if (!disintegrate_as_static)
				COLOR.a = r_alpha;
		}
	}

	// FOG
	if (fog_enabled) {
		vec2 fog_uv = MUV + fog_speed * TIME;
		float noise_alpha = texture(fog_noise_texture, fog_uv).r;
		// Convert noise from (0.0, 1.0) to (-1.0, 1.0)
		float fog = clamp((noise_alpha * 2.0 - 1.0) + (fog_density * 2.0), 0.0, 1.0);
		COLOR.a *= fog * fog_opacity;
	}

	// COLORLINES	
	if (!is_exclude_color) {
		if (X % vertical_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, vertical_colorline_color, vertical_colorline_strength);
		}
		if (Y % horizontal_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, horizontal_colorline_color, horizontal_colorline_strength);
		}
	}

	// CHECKER
	if (!is_exclude_color) {	
		if (X/checker_x_size % checker_x_pattern != Y/checker_y_size % checker_y_pattern) {
			float pixel_darkness = (3.0 - (COLOR.r + COLOR.g + COLOR.b)) * checker_contrast_ratio; // calculates 0.0 to 1.0 where 1.0 is pure black and 0.0 is pure white
			vec3 cbcolor = mix(checker_color.rgb, vec3(0.0), pixel_darkness * checker_contrast_amount);
			COLOR.rgb = mix(COLOR.rgb, cbcolor, checker_strength);
		}
	}

	// MOUSELIGHT
	if (mouselight_on && (!mouselight_checker || X % 2 == Y % 2)) {
		float mouse_with_flicker = mix(auto_mouselight_flicker_bound, float(mouselight_size), vary0to1(TIME * auto_mouselight_flicker_speed));
		float dist_from_mouse = sqrt(pow(float(_SCREEN_PIXEL_X - int(MOUSE.x)), 2.0) + pow(float(_SCREEN_PIXEL_Y - int(MOUSE.y)), 2.0));
		if (dist_from_mouse <= float(mouse_with_flicker)) {
			//todo - make softening with distance optional as uniform
			float distance_mod = clamp((mouse_with_flicker - dist_from_mouse) / mouse_with_flicker, 0.0, 1.0);
			COLOR.rgb = mix(COLOR.rgb, mouselight_color, distance_mod * mouselight_strength);
		}
	}

	// CUT
	if (MUV.x < cut_left)
		COLOR.a = 0.0;
	if (MUV.x > 1.0-cut_right)
		COLOR.a = 0.0;
	if (MUV.y < cut_top)
		COLOR.a = 0.0;
	if (MUV.y > 1.0-cut_bottom)
		COLOR.a = 0.0;

	// VIGNETTE
	if (vignette_on && ((!vignette_ignore_transparent || COLOR.a != 0.0)) && !is_exclude_color) {
		float x = abs(adjUV.x-.5)*2.0;
		float y = abs(adjUV.y-.5)*2.0;
		float v = (sqrt((x*x)+(y*y))/vignette_radius);
		COLOR = mix(COLOR, vec4(vignette_color.r, vignette_color.g, vignette_color.b, 1.0), v);
	}

	// TRANSPARENCY
	if (COLOR.a != 0.0) {
		COLOR.a = mix(COLOR.a * transparency, auto_flicker_bound, vary0to1((TIME-auto_flicker_start_time + TIME_OFFSET) * auto_flicker_speed));
	}
}

void vertex()
{
	
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_aonxi"]
shader = SubResource("Shader_yc8jt")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(0.360784, 0.552941, 0.741176, 1)
shader_parameter/auto_flash_speed = 5.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 0.2
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="Shader" id="Shader_ctmx8"]
code = "// Ben's Uber Pixel Shader
// WARNING - Shader expects uniform inputs in the range 0.0 - 1.0 for Colors. 
//           Therefore, be sure that Colors being passed in are in the correct range of (0-1, 0-1, 0-1, 0-1).
shader_type canvas_item;

// --- Utilty Functions --- //
const bool DEBUG = true;
const float TIME_OFFSET = 10.0; //offset all start times by this... for some reason things line up better with expectations
const vec2 HORIZONTAL_VERTICAL_OFFSETS[4] = {vec2(0, 1), vec2(-1, 0), vec2(1, 0), vec2(0, -1)};
const vec2 DIAGONAL_OUTLINE_OFFSETS[4] = {vec2(1, 1), vec2(-1, 1), vec2(1, -1), vec2(-1, -1)};

// checks if two values are 'equal' (within EPSILON of each other)
// necessary when doing float calculations since it's not perfectly precise
const float EPSILON = 0.001;
bool floateq(float val1, float val2) { return val1 >= val2 - EPSILON && val1 <= val2 + EPSILON; }
bool vec3eq(vec3 val1, vec3 val2) { return floateq(val1.r, val2.r) && floateq(val1.g, val2.g) && floateq(val1.b, val2.b); }

// Author: Michael Pohoreski https://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader
float random(vec2 seed){ return fract(cos(dot(seed, vec2(23.14069263277926, 2.665144142690225))) * 12345.6789); }
float snoise3(vec2 seed) { return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453); }
float randf_range(vec2 seed, float b1, float b2) { return mix(b1, b2, random(seed)); }
int randi_range(vec2 seed, int b1, int b2) { return int(randf_range(seed, float(b1), float(b2))); }
float sin0to1(float time) { return (sin(time)+1.0)/2.0; }
float cos0to1(float time) { return (cos(time)+1.0)/2.0; } 
float vary0to1(float time) { return 1.0-(cos(time)+1.0)/2.0; } // a transformed cos function that varies from 0 to 1. f(0) = 0, f(pi) = 1, f(2pi) = 0. 

uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;

uniform bool POST_PROCESSING = false;

// pass in the mouse position here
uniform vec2 MOUSE = vec2(20, 20);


// --- Effects --- //
// EXCLUDE
// If use_exclude_colors, pixels of these colors are excluded from tint, color correction, scanline, and vignette effects.
group_uniforms Exclude;
uniform bool use_exclude_colors = true;
uniform vec3 exclude_color1: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color2: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color3: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color4: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders

// PAN/DISPLACE
// Displaces all pixels by (displace_x, displace_y). Texture repeats if displace_repeat.
// WARNING - Offsetting beyond the bounds of the texture will result in the texture being cut off
group_uniforms PanAndDisplacement;
uniform int displace_x = 0;
uniform int displace_y = 0;
uniform bool displace_repeat = true;
// Texture will automatically scroll if auto_pan_speed is nonzero.
// Set auto_pan_speed to a positive number for left/up panning; negative number for right/down panning
// WARNING - Repeat generally should be true for auto_pan_speed, otherwise it will immediately pan out of view
uniform vec2 auto_pan_speed = vec2(0, 0);

// RECOLOR
// Replaces replace_colorN with replace_with_colorN.
group_uniforms Recolor;
uniform vec3 replace_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color5: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color5: source_color = vec3(0.0, 0.0, 0.0);

// special extra uniform specifically intended to recolor outlines
uniform vec3 replace_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 replace_with_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392);

// TINT
// Tint the texture with tint_color.
// The strength of the tint is controlled by tint_strength.
group_uniforms Tint;
uniform vec3 tint_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float tint_strength: hint_range(0.0, 1.0) = 0.0;

// FLASH
// Flash the texture with flash_color. Essentially, this is a second layer of tint.
// flash_strength controls how much color is the original and how much is the flash_color.
group_uniforms Flash;
uniform vec3 flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float flash_strength: hint_range(0.0, 1.0) = 0.0;
// auto_flash_speed will cause infinite and repeated flashing in auto_flash_color if nonzero and controls the speed of this flashing.
// auto_flash_bound1 and auto_flash_bound2 provide the bounds of the flashing effect.
// To prevent the auto flash from starting in the middle of the animation, set auto_flash_start_time to the global time when enabling auto flash.
// TIP - auto flash and regular ('manual') flash stack, which is why they have two separate colors.
uniform vec3 auto_flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float auto_flash_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flash_bound1: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flash_bound2: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flash_start_time = 0.0;

// COLOR CORRECTION
group_uniforms ColorCorrection;
// Applies red, green, or blue color correction with red_correct, green_correct, and blue_correct. 
// Applies grayscale with gray_correct.
// Modify brightness, contrast, or saturation with brightness_correct, contrast_correct, and saturation_correct.
// TIP - these values can actually go higher or lower, if you want a more extreme effect
uniform float red_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float green_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float blue_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float gray_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float brightness_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float contrast_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float saturation_correct: hint_range(0.0, 2.0, 0.01) = 1.0;

// TODO - more funky color options
// rg swap - swaps the original (before any other swaps) value of r and g
// gb swap
// br swap
// r_eq_g - sets r = g
// r_eq_b
// g_eq_r
// g_eq_b
// b_eq_r
// b_eq_g

// TODO - ROUGHEN - applies randomized brightness modifications across the texture (both positive and negative) to 'roughen' it up

// SCANLINES
// Create a line across the canvas of scanline_color. scanline_strength controls the alpha of the line.
// Define the position of the line with scanline_left_to_right_position, scanline_top_to_bottom_position,
// scanline_topleft_to_bottomright_position, and scanline_topright_to_bottomleft_position.
// The line is vertical if going left to right, horizontal if going top to bottom, and diagonal for the other two.
group_uniforms Scanline;
uniform vec3 scanline_color: source_color = vec3(0.98, 0.69, 0.23);
uniform float scanline_strength: hint_range(0.0, 1.0, 0.01) = 1.0;
uniform float scanline_left_to_right_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_top_to_bottom_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topleft_to_bottomright_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topright_to_bottomleft_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
// auto_scanline_DIRECTION_on will enable automatic repeating scanlines in that direction.
// auto_scanline_DIRECTION_reverse will flip the direction.
// The scan will be visible for auto_scanline_DIRECTION_scan_duration, with a delay of 
// auto_scanline_DIRECTION_scan_duration before the next scan begins.
// To prevent the scanline from starting in the middle of the texture, provide the global time to auto_scanline_DIRECTION_start_time.
uniform bool auto_scanline_left_to_right_on = false;
uniform bool auto_scanline_left_to_right_reverse = false;
uniform float auto_scanline_left_to_right_start_time = 0.0;
uniform float auto_scanline_left_to_right_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_left_to_right_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_top_to_bottom_on = false;
uniform bool auto_scanline_top_to_bottom_reverse = false;
uniform float auto_scanline_top_to_bottom_start_time = 0.0;
uniform float auto_scanline_top_to_bottom_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_top_to_bottom_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topleft_to_bottomright_on = false;
uniform bool auto_scanline_topleft_to_bottomright_reverse = false;
uniform float auto_scanline_topleft_to_bottomright_start_time = 0.0;
uniform float auto_scanline_topleft_to_bottomright_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topleft_to_bottomright_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topright_to_bottomleft_on = false;
uniform bool auto_scanline_topright_to_bottomleft_reverse = false;
uniform float auto_scanline_topright_to_bottomleft_start_time = 0.0;
uniform float auto_scanline_topright_to_bottomleft_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topright_to_bottomleft_delay: hint_range(0.0, 10.0, 0.01) = 1.0;

// OUTLINE
// Adds a pixel outline to the texture, with glow_color and glow_thickness.
// glow_dialgonals controls if we also create this outline diagonally, which makes it thicker.
// This can be used to create a solid outline if auto_glow_speed is left at 0.
// WARNING - Shaders cannot draw outside of the bounds of the canvas, so the canvas may need extra transparent space on the sides.
// WARNING - Can have some odd effects with sprites containing partial transparency.
group_uniforms GlowAndOutline;
uniform vec4 glow_color: source_color = vec4(1.0);
uniform int glow_thickness: hint_range(0, 10) = 0;
uniform bool glow_diagonals = false;
// auto_glow_speed defines the speed of a glow fluctuating alpha between the outline's alpha and auto_glow_bound at auto_glow_speed.
// To prevent the auto glow from starting in the middle of the animation, set auto_glow_start_time to the global time when enabling auto glow.
uniform float auto_glow_speed: hint_range(0.0, 30.0) = 0.0;
uniform float auto_glow_bound: hint_range(0.0, 1.0) = 0.75;
uniform float auto_glow_start_time = 0.0;

// DISINTEGRATE
// Sets 'random' pixels in the canvas to disintegrate_color with alpha between disintegrate_alpha_bound1 and disintegrate_alpha_bound2.
// By default, since these bounds are 0, the pixels will be made fully transparent and therefore disintegrate_color is unused.
// disintegrate_strength controls the amount of pixels affected, from none (0) to all of them (1).
// Change the pattern via disintegrate_seed.
// disintegrate_as_static changes the purpose of disintegrate to not affect the alpha of the texture.
// Instead, it layers a static-looking pattern on top using disintegrate_color, where the color is based on disintegrate_color
// and the alpha of the static pattern ranges randomly between disintegrate_alpha_bound1 and disintegrate_alpha_bound2 per pixel.
// Note that with the default bounds of 0 and 0, this setting creates no effect whatsoever.
// If auto_disintegrate_random_seed_speed is nonzero, applies randomization to the seed over time based on speed.
// In this case, disintegrate_seed has no effect.
group_uniforms Disintegrate;
uniform int disintegrate_seed = 1;
uniform vec3 disintegrate_color : source_color = vec3(0.0, 0.0, 0.0);
uniform float disintegrate_strength: hint_range(0.0, 1.0) = 0.0;
uniform float disintegrate_alpha_bound1 = 0.0;
uniform float disintegrate_alpha_bound2 = 0.0;
uniform bool disintegrate_as_static = false;
uniform float auto_disintegrate_random_seed_speed: hint_range(0.0, 1.0) = 0.0;

// FOG
// Applies a fog_noise_texture filter over the texture with modifiable fog_opacity and fog_density, moving at fog_speed
// Mostly used to create fog effects by assigning to a ColorRect (color is changable by changing ColorRect color too!)
// NOTE - Don't use this as a post processing shader. 
group_uniforms Fog;
uniform bool fog_enabled = false;
uniform sampler2D fog_noise_texture: repeat_enable, filter_nearest;
uniform float fog_opacity: hint_range(0.0, 1.0) = 0.5;
uniform float fog_density: hint_range(0.0, 1.0) = 0.25;
uniform vec2 fog_speed = vec2(-0.02, 0.0);

// COLORLINES
// Creates vertical/horizontal lines of colorline_color spaced colorline_spacing pixels apart 
// with colorline_strength alpha across the texture.
group_uniforms Colorlines;
uniform vec3 vertical_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int vertical_colorline_spacing = 2;
uniform float vertical_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;
uniform vec3 horizontal_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int horizontal_colorline_spacing = 2;
uniform float horizontal_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;

// CHECKER
// Creates a checkerboard pattern across the texture of checker_color with checker_strength alpha.
// checker_x_size and checker_y_size defines the size of each rectangular checker
// checker_x_pattern and checker_y_pattern affect the pattern of the checker pattern (which
// can stop looking checkered with different values).
// checker_contrast_amount applies a darkening effect to pixels of the checkerboard that are already dark.
// checker_contrast_ratio increases the contrast of the darkening effect between light and dark colored pixels,
// ie dark pixels become even darker.
group_uniforms CHECKER;
uniform vec3 checker_color: source_color = vec3(0.2, 0.2, 0.2);
uniform float checker_strength: hint_range(0.0, 1.0, 0.01) = 0.0; //0.3 is a good one
uniform int checker_x_size: hint_range(1, 64, 1) = 1;
uniform int checker_y_size: hint_range(1, 64, 1) = 1;
uniform int checker_x_pattern: hint_range(1, 32, 1) = 2;
uniform int checker_y_pattern: hint_range(1, 32, 1) = 2;
uniform float checker_contrast_amount: hint_range(-10.0, 10.0, 0.1) = 1.0;
uniform float checker_contrast_ratio: hint_range(0.0, 10.0, 0.01) = 0.5;
// TODO - experiment a bit more with the contrast calculation here - maybe subtract 0.5 and LIGHTEN lighter areas?

// MOUSELIGHT
// Creates a circular lighting effect at the mouse's position if mouselight_on, of mouselight_color and mouselight_strength alpha.
// Mouselight size defines the radius of the light effect.
// If mouselight_soften_edges, pixels further from the center of the light are more transparent.
// If mouselight_checker, the effect will be checkered in a way that interacts with the CHECKER effect.
// If auto_mouselight_flicker_speed is non-zero, the light will oscillate in size between mouselight_size and auto_mouselight_flicker_speed
group_uniforms Mouselight;
uniform bool mouselight_on = false;
uniform vec3 mouselight_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float mouselight_strength = 0.5;
uniform int mouselight_size = 8;
uniform bool mouselight_soften_edges = true;
uniform bool mouselight_checker = false;
uniform float auto_mouselight_flicker_speed: hint_range(0.0, 20.0) = 8;
uniform float auto_mouselight_flicker_bound = 10;

// CUT
// Cuts off all pixels of the texture from left/right/top/bottom.
group_uniforms Cut;
uniform float cut_left: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_right: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_top: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_bottom: hint_range(0.0, 1.0, 0.001) = 0.0;

// VIGNETTE
// Applies a circular vignette effect on the canvas if vignette_on.
// The vignette has a vignette_radius and a vignette_color.
// If vignette_ignore_transparent, transparent pixels will not have the vignette applied.
// This is generally useful if you want to apply a vignette on something besides the entire screen.
// Radius -> 0 tends to do some crazy effects
group_uniforms Vignette;
uniform bool vignette_on = false;
uniform bool vignette_ignore_transparent = false;
uniform vec3 vignette_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float vignette_radius: hint_range(0.001, 20.0, 0.01) = 1.0;

// TRANSPARENCY
// Controls transparency of the texture.
// If auto_flicker_speed is not zero, oscillates between transparency and auto_flicker_bounds at auto_flicker_speed.
// To prevent the auto flicker from starting in the middle of the animation, set auto_flicker_start_time to the global time when enabling auto flicker.
group_uniforms Transparency;
uniform float transparency: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flicker_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flicker_bound: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flicker_start_time = 0.0;

// --- Fragment Shader --- //
void fragment() 
{
	COLOR = texture(TEXTURE, UV);
	
	// --- CALCULATE CONSTANTS ---
	// WARNING - Don't use the ones with _ directly. 
	// the size of this canvas in pixels (ex 10x10)
	int _SIZE_IN_PIXELS_X = int(floor(1.0 / TEXTURE_PIXEL_SIZE.x));
	int _SIZE_IN_PIXELS_Y = int(floor(1.0 / TEXTURE_PIXEL_SIZE.y));
	// the size of the screen in pixels (ex 320x180)
	int _SCREEN_SIZE_IN_PIXELS_X = int(floor(1.0 / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_SIZE_IN_PIXELS_Y = int(floor(1.0 / SCREEN_PIXEL_SIZE.y));
	
	// the specific x and y pixel coordinates within texture
	int _PIXEL_X = int(floor(UV.x / TEXTURE_PIXEL_SIZE.x));
	int _PIXEL_Y = int(floor(UV.y / TEXTURE_PIXEL_SIZE.y));
	// the specific x and y pixel coordinates within screen
	int _SCREEN_PIXEL_X = int(floor(SCREEN_UV.x / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_PIXEL_Y = int(floor(SCREEN_UV.y / SCREEN_PIXEL_SIZE.y));
	
	// WARNING - Use these instead. This accounts for if this is a normal or post processing shader.
	// Size of a pixel for this canvas (ie 1/320x1/180)
	float PIXEL_SIZE_X = POST_PROCESSING ? SCREEN_PIXEL_SIZE.x : TEXTURE_PIXEL_SIZE.x;
	float PIXEL_SIZE_Y = POST_PROCESSING ? SCREEN_PIXEL_SIZE.y : TEXTURE_PIXEL_SIZE.y;
	// Size of the canvas in pixels. (ex 320x180)
	int SIZE_IN_PIXELS_X = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_X : _SIZE_IN_PIXELS_X;
	int SIZE_IN_PIXELS_Y = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_Y : _SIZE_IN_PIXELS_Y;
	// The specific XY coordinates of the current pixel.
	int X = POST_PROCESSING ? _SCREEN_PIXEL_X : _PIXEL_X;
	int Y = POST_PROCESSING ? _SCREEN_PIXEL_Y : _PIXEL_Y;
	// UV coordinates of the current pixel.
	vec2 MUV = POST_PROCESSING ? SCREEN_UV : UV;
	// ---
	
	
	// DISPLACE & PAN
	vec2 adjUV = vec2(0, 0); // WARNING - Use this instead of UV below, otherwise effects break with panning & displace
	
	float displaceUVX = MUV.x + (SCREEN_PIXEL_SIZE.x * float(displace_x));
	float displaceUVY = MUV.y + (SCREEN_PIXEL_SIZE.y * float(displace_y));
	if (displace_repeat) {
		adjUV = mod(vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed, 1.00000);
	} else {
		adjUV = vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed;
	}
	
	// $HACK$ doing this as a ternary breaks the preview, for some reason
	if (POST_PROCESSING) 
		COLOR = texture(SCREEN_TEXTURE, adjUV);
	else 
		COLOR = texture(TEXTURE, adjUV);
	
	// EXCLUDE COLORS
	bool is_exclude_color = use_exclude_colors && (vec3eq(COLOR.rgb, exclude_color1) || vec3eq(COLOR.rgb, exclude_color2) || vec3eq(COLOR.rgb, exclude_color3) || vec3eq(COLOR.rgb, exclude_color4));
	
	// RECOLOR
	if (vec3eq(COLOR.rgb, replace_color1)) 
		COLOR.rgb = replace_with_color1;
	if (vec3eq(COLOR.rgb, replace_color2)) 
		COLOR.rgb = replace_with_color2;
	if (vec3eq(COLOR.rgb, replace_color3)) 
		COLOR.rgb = replace_with_color3;
	if (vec3eq(COLOR.rgb, replace_color4)) 
		COLOR.rgb = replace_with_color4;
	if (vec3eq(COLOR.rgb, replace_color5)) 
		COLOR.rgb = replace_with_color5;
	if (vec3eq(COLOR.rgb, replace_color_outline))
		COLOR.rgb = replace_with_color_outline;
	
	// TINT, COLOR CORRECTION, and SCANLINE ignore excluded colors
	if (!is_exclude_color) {
		// TINT
		COLOR.rgb = mix(COLOR.rgb, tint_color, tint_strength);

		// FLASH
		// apply automatic flash
		if (auto_flash_speed != 0.0) {
			float auto_strength = mix(auto_flash_bound1, auto_flash_bound2, abs(vary0to1((TIME-auto_flash_start_time + TIME_OFFSET) * auto_flash_speed)));
			COLOR.rgb = mix(COLOR.rgb, auto_flash_color, auto_strength);
		}
		// apply manual flash
		COLOR.rgb = mix(COLOR.rgb, flash_color, flash_strength);

		// COLOR CORRECTION
		COLOR.r = mix(COLOR.r, 1.0, red_correct);
		COLOR.g = mix(COLOR.g, 1.0, green_correct);
		COLOR.b = mix(COLOR.b, 1.0, blue_correct);
		COLOR.rgb = mix(COLOR.rgb, vec3(0.2126 * COLOR.r + 0.7152 * COLOR.g + 0.0722 * COLOR.b), gray_correct);
		COLOR.rgb = mix(vec3(0.0), COLOR.rgb, brightness_correct);
		COLOR.rgb = mix(vec3(0.5), COLOR.rgb, contrast_correct);
		COLOR.rgb = mix(vec3(dot(vec3(1.0), COLOR.rbg)), COLOR.rgb, saturation_correct);

		// SCANLINE
		// FIX
		if (COLOR.a != 0.0) {
			float l_to_r_pos = !auto_scanline_left_to_right_on ? scanline_left_to_right_position : abs((auto_scanline_left_to_right_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_left_to_right_start_time + TIME_OFFSET, auto_scanline_left_to_right_delay + auto_scanline_left_to_right_scan_duration), 0.0, auto_scanline_left_to_right_scan_duration)/auto_scanline_left_to_right_scan_duration)));
			float t_to_b_pos = !auto_scanline_top_to_bottom_on ? scanline_top_to_bottom_position : abs((auto_scanline_top_to_bottom_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_top_to_bottom_start_time + TIME_OFFSET, auto_scanline_top_to_bottom_delay + auto_scanline_top_to_bottom_scan_duration), 0.0, auto_scanline_top_to_bottom_scan_duration)/auto_scanline_top_to_bottom_scan_duration)));
			float tl_to_br_pos = !auto_scanline_topleft_to_bottomright_on ? scanline_topleft_to_bottomright_position : abs((auto_scanline_topleft_to_bottomright_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topleft_to_bottomright_start_time + TIME_OFFSET, auto_scanline_topleft_to_bottomright_delay + auto_scanline_topleft_to_bottomright_scan_duration), 0.0, auto_scanline_topleft_to_bottomright_scan_duration)/auto_scanline_topleft_to_bottomright_scan_duration)));
			float tr_to_bl_pos = !auto_scanline_topright_to_bottomleft_on ? scanline_topright_to_bottomleft_position : abs((auto_scanline_topright_to_bottomleft_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topright_to_bottomleft_start_time + TIME_OFFSET, auto_scanline_topright_to_bottomleft_delay + auto_scanline_topright_to_bottomleft_scan_duration), 0.0, auto_scanline_topright_to_bottomleft_scan_duration)/auto_scanline_topright_to_bottomleft_scan_duration)));

			if (X == int(floor(l_to_r_pos / float(PIXEL_SIZE_X))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (Y == int(floor(t_to_b_pos / float(PIXEL_SIZE_Y))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			int scanline_target_tlbr = int(floor(tl_to_br_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y)));
			int scanline_target_trbl = int(floor(tr_to_bl_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y))) - SIZE_IN_PIXELS_Y;
			if (X+Y == scanline_target_tlbr)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (X-Y == scanline_target_trbl)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
		}
	}

	// GLOW
	if (glow_thickness != 0) {
		vec2 outline_size = TEXTURE_PIXEL_SIZE * float(glow_thickness);
		float outline = 0.0;
		for (int i = 0; i < HORIZONTAL_VERTICAL_OFFSETS.length(); i++) {
			outline += texture(TEXTURE, adjUV + outline_size * HORIZONTAL_VERTICAL_OFFSETS[i]).a;
		}
		if (glow_diagonals) {
			for (int i = 0; i < DIAGONAL_OUTLINE_OFFSETS.length(); i++) {
				outline += texture(TEXTURE, adjUV + outline_size * DIAGONAL_OUTLINE_OFFSETS[i]).a;
			}
		}
		outline = min(outline, 1.0);
		// this is a bit of a coding $HACK$ to make auto_glow_bound do nothing if auto_glow_speed is 0, but it definitely works
		float alp = auto_glow_speed == 0.0 ? 1.0 : mix(auto_glow_bound, glow_color.a, vary0to1((TIME - auto_glow_start_time + TIME_OFFSET) * auto_glow_speed));
		COLOR = mix(COLOR, glow_color * alp, outline - COLOR.a);
	}

	// DISINTEGRATE
	if (!is_exclude_color && COLOR.a != 0.0) {
		vec2 s = adjUV * vec2(float(disintegrate_seed));
		s *= auto_disintegrate_random_seed_speed != 0.0 ? float(int(TIME / mix(1.0, 0.001, auto_disintegrate_random_seed_speed))) : 1.0;
		float r = random(s);
		if (r < disintegrate_strength) {
			float r_alpha = randf_range(s, disintegrate_alpha_bound1, disintegrate_alpha_bound2);
			COLOR.rgb = mix(COLOR.rgb, disintegrate_color, r_alpha);
			if (!disintegrate_as_static)
				COLOR.a = r_alpha;
		}
	}

	// FOG
	if (fog_enabled) {
		vec2 fog_uv = MUV + fog_speed * TIME;
		float noise_alpha = texture(fog_noise_texture, fog_uv).r;
		// Convert noise from (0.0, 1.0) to (-1.0, 1.0)
		float fog = clamp((noise_alpha * 2.0 - 1.0) + (fog_density * 2.0), 0.0, 1.0);
		COLOR.a *= fog * fog_opacity;
	}

	// COLORLINES	
	if (!is_exclude_color) {
		if (X % vertical_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, vertical_colorline_color, vertical_colorline_strength);
		}
		if (Y % horizontal_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, horizontal_colorline_color, horizontal_colorline_strength);
		}
	}

	// CHECKER
	if (!is_exclude_color) {	
		if (X/checker_x_size % checker_x_pattern != Y/checker_y_size % checker_y_pattern) {
			float pixel_darkness = (3.0 - (COLOR.r + COLOR.g + COLOR.b)) * checker_contrast_ratio; // calculates 0.0 to 1.0 where 1.0 is pure black and 0.0 is pure white
			vec3 cbcolor = mix(checker_color.rgb, vec3(0.0), pixel_darkness * checker_contrast_amount);
			COLOR.rgb = mix(COLOR.rgb, cbcolor, checker_strength);
		}
	}

	// MOUSELIGHT
	if (mouselight_on && (!mouselight_checker || X % 2 == Y % 2)) {
		float mouse_with_flicker = mix(auto_mouselight_flicker_bound, float(mouselight_size), vary0to1(TIME * auto_mouselight_flicker_speed));
		float dist_from_mouse = sqrt(pow(float(_SCREEN_PIXEL_X - int(MOUSE.x)), 2.0) + pow(float(_SCREEN_PIXEL_Y - int(MOUSE.y)), 2.0));
		if (dist_from_mouse <= float(mouse_with_flicker)) {
			//todo - make softening with distance optional as uniform
			float distance_mod = clamp((mouse_with_flicker - dist_from_mouse) / mouse_with_flicker, 0.0, 1.0);
			COLOR.rgb = mix(COLOR.rgb, mouselight_color, distance_mod * mouselight_strength);
		}
	}

	// CUT
	if (MUV.x < cut_left)
		COLOR.a = 0.0;
	if (MUV.x > 1.0-cut_right)
		COLOR.a = 0.0;
	if (MUV.y < cut_top)
		COLOR.a = 0.0;
	if (MUV.y > 1.0-cut_bottom)
		COLOR.a = 0.0;

	// VIGNETTE
	if (vignette_on && ((!vignette_ignore_transparent || COLOR.a != 0.0)) && !is_exclude_color) {
		float x = abs(adjUV.x-.5)*2.0;
		float y = abs(adjUV.y-.5)*2.0;
		float v = (sqrt((x*x)+(y*y))/vignette_radius);
		COLOR = mix(COLOR, vec4(vignette_color.r, vignette_color.g, vignette_color.b, 1.0), v);
	}

	// TRANSPARENCY
	if (COLOR.a != 0.0) {
		COLOR.a = mix(COLOR.a * transparency, auto_flicker_bound, vary0to1((TIME-auto_flicker_start_time + TIME_OFFSET) * auto_flicker_speed));
	}
}

void vertex()
{
	
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_egygr"]
shader = SubResource("Shader_ctmx8")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(0.784314, 0.180392, 0.952941, 1)
shader_parameter/auto_flash_speed = 5.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 0.2
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="Shader" id="Shader_vl1yy"]
code = "// Ben's Uber Pixel Shader
// WARNING - Shader expects uniform inputs in the range 0.0 - 1.0 for Colors. 
//           Therefore, be sure that Colors being passed in are in the correct range of (0-1, 0-1, 0-1, 0-1).
shader_type canvas_item;

// --- Utilty Functions --- //
const bool DEBUG = true;
const float TIME_OFFSET = 10.0; //offset all start times by this... for some reason things line up better with expectations
const vec2 HORIZONTAL_VERTICAL_OFFSETS[4] = {vec2(0, 1), vec2(-1, 0), vec2(1, 0), vec2(0, -1)};
const vec2 DIAGONAL_OUTLINE_OFFSETS[4] = {vec2(1, 1), vec2(-1, 1), vec2(1, -1), vec2(-1, -1)};

// checks if two values are 'equal' (within EPSILON of each other)
// necessary when doing float calculations since it's not perfectly precise
const float EPSILON = 0.001;
bool floateq(float val1, float val2) { return val1 >= val2 - EPSILON && val1 <= val2 + EPSILON; }
bool vec3eq(vec3 val1, vec3 val2) { return floateq(val1.r, val2.r) && floateq(val1.g, val2.g) && floateq(val1.b, val2.b); }

// Author: Michael Pohoreski https://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader
float random(vec2 seed){ return fract(cos(dot(seed, vec2(23.14069263277926, 2.665144142690225))) * 12345.6789); }
float snoise3(vec2 seed) { return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453); }
float randf_range(vec2 seed, float b1, float b2) { return mix(b1, b2, random(seed)); }
int randi_range(vec2 seed, int b1, int b2) { return int(randf_range(seed, float(b1), float(b2))); }
float sin0to1(float time) { return (sin(time)+1.0)/2.0; }
float cos0to1(float time) { return (cos(time)+1.0)/2.0; } 
float vary0to1(float time) { return 1.0-(cos(time)+1.0)/2.0; } // a transformed cos function that varies from 0 to 1. f(0) = 0, f(pi) = 1, f(2pi) = 0. 

uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;

uniform bool POST_PROCESSING = false;

// pass in the mouse position here
uniform vec2 MOUSE = vec2(20, 20);


// --- Effects --- //
// EXCLUDE
// If use_exclude_colors, pixels of these colors are excluded from tint, color correction, scanline, and vignette effects.
group_uniforms Exclude;
uniform bool use_exclude_colors = true;
uniform vec3 exclude_color1: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color2: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color3: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color4: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders

// PAN/DISPLACE
// Displaces all pixels by (displace_x, displace_y). Texture repeats if displace_repeat.
// WARNING - Offsetting beyond the bounds of the texture will result in the texture being cut off
group_uniforms PanAndDisplacement;
uniform int displace_x = 0;
uniform int displace_y = 0;
uniform bool displace_repeat = true;
// Texture will automatically scroll if auto_pan_speed is nonzero.
// Set auto_pan_speed to a positive number for left/up panning; negative number for right/down panning
// WARNING - Repeat generally should be true for auto_pan_speed, otherwise it will immediately pan out of view
uniform vec2 auto_pan_speed = vec2(0, 0);

// RECOLOR
// Replaces replace_colorN with replace_with_colorN.
group_uniforms Recolor;
uniform vec3 replace_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color5: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color5: source_color = vec3(0.0, 0.0, 0.0);

// special extra uniform specifically intended to recolor outlines
uniform vec3 replace_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 replace_with_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392);

// TINT
// Tint the texture with tint_color.
// The strength of the tint is controlled by tint_strength.
group_uniforms Tint;
uniform vec3 tint_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float tint_strength: hint_range(0.0, 1.0) = 0.0;

// FLASH
// Flash the texture with flash_color. Essentially, this is a second layer of tint.
// flash_strength controls how much color is the original and how much is the flash_color.
group_uniforms Flash;
uniform vec3 flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float flash_strength: hint_range(0.0, 1.0) = 0.0;
// auto_flash_speed will cause infinite and repeated flashing in auto_flash_color if nonzero and controls the speed of this flashing.
// auto_flash_bound1 and auto_flash_bound2 provide the bounds of the flashing effect.
// To prevent the auto flash from starting in the middle of the animation, set auto_flash_start_time to the global time when enabling auto flash.
// TIP - auto flash and regular ('manual') flash stack, which is why they have two separate colors.
uniform vec3 auto_flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float auto_flash_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flash_bound1: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flash_bound2: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flash_start_time = 0.0;

// COLOR CORRECTION
group_uniforms ColorCorrection;
// Applies red, green, or blue color correction with red_correct, green_correct, and blue_correct. 
// Applies grayscale with gray_correct.
// Modify brightness, contrast, or saturation with brightness_correct, contrast_correct, and saturation_correct.
// TIP - these values can actually go higher or lower, if you want a more extreme effect
uniform float red_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float green_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float blue_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float gray_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float brightness_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float contrast_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float saturation_correct: hint_range(0.0, 2.0, 0.01) = 1.0;

// TODO - more funky color options
// rg swap - swaps the original (before any other swaps) value of r and g
// gb swap
// br swap
// r_eq_g - sets r = g
// r_eq_b
// g_eq_r
// g_eq_b
// b_eq_r
// b_eq_g

// TODO - ROUGHEN - applies randomized brightness modifications across the texture (both positive and negative) to 'roughen' it up

// SCANLINES
// Create a line across the canvas of scanline_color. scanline_strength controls the alpha of the line.
// Define the position of the line with scanline_left_to_right_position, scanline_top_to_bottom_position,
// scanline_topleft_to_bottomright_position, and scanline_topright_to_bottomleft_position.
// The line is vertical if going left to right, horizontal if going top to bottom, and diagonal for the other two.
group_uniforms Scanline;
uniform vec3 scanline_color: source_color = vec3(0.98, 0.69, 0.23);
uniform float scanline_strength: hint_range(0.0, 1.0, 0.01) = 1.0;
uniform float scanline_left_to_right_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_top_to_bottom_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topleft_to_bottomright_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topright_to_bottomleft_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
// auto_scanline_DIRECTION_on will enable automatic repeating scanlines in that direction.
// auto_scanline_DIRECTION_reverse will flip the direction.
// The scan will be visible for auto_scanline_DIRECTION_scan_duration, with a delay of 
// auto_scanline_DIRECTION_scan_duration before the next scan begins.
// To prevent the scanline from starting in the middle of the texture, provide the global time to auto_scanline_DIRECTION_start_time.
uniform bool auto_scanline_left_to_right_on = false;
uniform bool auto_scanline_left_to_right_reverse = false;
uniform float auto_scanline_left_to_right_start_time = 0.0;
uniform float auto_scanline_left_to_right_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_left_to_right_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_top_to_bottom_on = false;
uniform bool auto_scanline_top_to_bottom_reverse = false;
uniform float auto_scanline_top_to_bottom_start_time = 0.0;
uniform float auto_scanline_top_to_bottom_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_top_to_bottom_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topleft_to_bottomright_on = false;
uniform bool auto_scanline_topleft_to_bottomright_reverse = false;
uniform float auto_scanline_topleft_to_bottomright_start_time = 0.0;
uniform float auto_scanline_topleft_to_bottomright_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topleft_to_bottomright_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topright_to_bottomleft_on = false;
uniform bool auto_scanline_topright_to_bottomleft_reverse = false;
uniform float auto_scanline_topright_to_bottomleft_start_time = 0.0;
uniform float auto_scanline_topright_to_bottomleft_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topright_to_bottomleft_delay: hint_range(0.0, 10.0, 0.01) = 1.0;

// OUTLINE
// Adds a pixel outline to the texture, with glow_color and glow_thickness.
// glow_dialgonals controls if we also create this outline diagonally, which makes it thicker.
// This can be used to create a solid outline if auto_glow_speed is left at 0.
// WARNING - Shaders cannot draw outside of the bounds of the canvas, so the canvas may need extra transparent space on the sides.
// WARNING - Can have some odd effects with sprites containing partial transparency.
group_uniforms GlowAndOutline;
uniform vec4 glow_color: source_color = vec4(1.0);
uniform int glow_thickness: hint_range(0, 10) = 0;
uniform bool glow_diagonals = false;
// auto_glow_speed defines the speed of a glow fluctuating alpha between the outline's alpha and auto_glow_bound at auto_glow_speed.
// To prevent the auto glow from starting in the middle of the animation, set auto_glow_start_time to the global time when enabling auto glow.
uniform float auto_glow_speed: hint_range(0.0, 30.0) = 0.0;
uniform float auto_glow_bound: hint_range(0.0, 1.0) = 0.75;
uniform float auto_glow_start_time = 0.0;

// DISINTEGRATE
// Sets 'random' pixels in the canvas to disintegrate_color with alpha between disintegrate_alpha_bound1 and disintegrate_alpha_bound2.
// By default, since these bounds are 0, the pixels will be made fully transparent and therefore disintegrate_color is unused.
// disintegrate_strength controls the amount of pixels affected, from none (0) to all of them (1).
// Change the pattern via disintegrate_seed.
// disintegrate_as_static changes the purpose of disintegrate to not affect the alpha of the texture.
// Instead, it layers a static-looking pattern on top using disintegrate_color, where the color is based on disintegrate_color
// and the alpha of the static pattern ranges randomly between disintegrate_alpha_bound1 and disintegrate_alpha_bound2 per pixel.
// Note that with the default bounds of 0 and 0, this setting creates no effect whatsoever.
// If auto_disintegrate_random_seed_speed is nonzero, applies randomization to the seed over time based on speed.
// In this case, disintegrate_seed has no effect.
group_uniforms Disintegrate;
uniform int disintegrate_seed = 1;
uniform vec3 disintegrate_color : source_color = vec3(0.0, 0.0, 0.0);
uniform float disintegrate_strength: hint_range(0.0, 1.0) = 0.0;
uniform float disintegrate_alpha_bound1 = 0.0;
uniform float disintegrate_alpha_bound2 = 0.0;
uniform bool disintegrate_as_static = false;
uniform float auto_disintegrate_random_seed_speed: hint_range(0.0, 1.0) = 0.0;

// FOG
// Applies a fog_noise_texture filter over the texture with modifiable fog_opacity and fog_density, moving at fog_speed
// Mostly used to create fog effects by assigning to a ColorRect (color is changable by changing ColorRect color too!)
// NOTE - Don't use this as a post processing shader. 
group_uniforms Fog;
uniform bool fog_enabled = false;
uniform sampler2D fog_noise_texture: repeat_enable, filter_nearest;
uniform float fog_opacity: hint_range(0.0, 1.0) = 0.5;
uniform float fog_density: hint_range(0.0, 1.0) = 0.25;
uniform vec2 fog_speed = vec2(-0.02, 0.0);

// COLORLINES
// Creates vertical/horizontal lines of colorline_color spaced colorline_spacing pixels apart 
// with colorline_strength alpha across the texture.
group_uniforms Colorlines;
uniform vec3 vertical_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int vertical_colorline_spacing = 2;
uniform float vertical_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;
uniform vec3 horizontal_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int horizontal_colorline_spacing = 2;
uniform float horizontal_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;

// CHECKER
// Creates a checkerboard pattern across the texture of checker_color with checker_strength alpha.
// checker_x_size and checker_y_size defines the size of each rectangular checker
// checker_x_pattern and checker_y_pattern affect the pattern of the checker pattern (which
// can stop looking checkered with different values).
// checker_contrast_amount applies a darkening effect to pixels of the checkerboard that are already dark.
// checker_contrast_ratio increases the contrast of the darkening effect between light and dark colored pixels,
// ie dark pixels become even darker.
group_uniforms CHECKER;
uniform vec3 checker_color: source_color = vec3(0.2, 0.2, 0.2);
uniform float checker_strength: hint_range(0.0, 1.0, 0.01) = 0.0; //0.3 is a good one
uniform int checker_x_size: hint_range(1, 64, 1) = 1;
uniform int checker_y_size: hint_range(1, 64, 1) = 1;
uniform int checker_x_pattern: hint_range(1, 32, 1) = 2;
uniform int checker_y_pattern: hint_range(1, 32, 1) = 2;
uniform float checker_contrast_amount: hint_range(-10.0, 10.0, 0.1) = 1.0;
uniform float checker_contrast_ratio: hint_range(0.0, 10.0, 0.01) = 0.5;
// TODO - experiment a bit more with the contrast calculation here - maybe subtract 0.5 and LIGHTEN lighter areas?

// MOUSELIGHT
// Creates a circular lighting effect at the mouse's position if mouselight_on, of mouselight_color and mouselight_strength alpha.
// Mouselight size defines the radius of the light effect.
// If mouselight_soften_edges, pixels further from the center of the light are more transparent.
// If mouselight_checker, the effect will be checkered in a way that interacts with the CHECKER effect.
// If auto_mouselight_flicker_speed is non-zero, the light will oscillate in size between mouselight_size and auto_mouselight_flicker_speed
group_uniforms Mouselight;
uniform bool mouselight_on = false;
uniform vec3 mouselight_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float mouselight_strength = 0.5;
uniform int mouselight_size = 8;
uniform bool mouselight_soften_edges = true;
uniform bool mouselight_checker = false;
uniform float auto_mouselight_flicker_speed: hint_range(0.0, 20.0) = 8;
uniform float auto_mouselight_flicker_bound = 10;

// CUT
// Cuts off all pixels of the texture from left/right/top/bottom.
group_uniforms Cut;
uniform float cut_left: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_right: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_top: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_bottom: hint_range(0.0, 1.0, 0.001) = 0.0;

// VIGNETTE
// Applies a circular vignette effect on the canvas if vignette_on.
// The vignette has a vignette_radius and a vignette_color.
// If vignette_ignore_transparent, transparent pixels will not have the vignette applied.
// This is generally useful if you want to apply a vignette on something besides the entire screen.
// Radius -> 0 tends to do some crazy effects
group_uniforms Vignette;
uniform bool vignette_on = false;
uniform bool vignette_ignore_transparent = false;
uniform vec3 vignette_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float vignette_radius: hint_range(0.001, 20.0, 0.01) = 1.0;

// TRANSPARENCY
// Controls transparency of the texture.
// If auto_flicker_speed is not zero, oscillates between transparency and auto_flicker_bounds at auto_flicker_speed.
// To prevent the auto flicker from starting in the middle of the animation, set auto_flicker_start_time to the global time when enabling auto flicker.
group_uniforms Transparency;
uniform float transparency: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flicker_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flicker_bound: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flicker_start_time = 0.0;

// --- Fragment Shader --- //
void fragment() 
{
	COLOR = texture(TEXTURE, UV);
	
	// --- CALCULATE CONSTANTS ---
	// WARNING - Don't use the ones with _ directly. 
	// the size of this canvas in pixels (ex 10x10)
	int _SIZE_IN_PIXELS_X = int(floor(1.0 / TEXTURE_PIXEL_SIZE.x));
	int _SIZE_IN_PIXELS_Y = int(floor(1.0 / TEXTURE_PIXEL_SIZE.y));
	// the size of the screen in pixels (ex 320x180)
	int _SCREEN_SIZE_IN_PIXELS_X = int(floor(1.0 / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_SIZE_IN_PIXELS_Y = int(floor(1.0 / SCREEN_PIXEL_SIZE.y));
	
	// the specific x and y pixel coordinates within texture
	int _PIXEL_X = int(floor(UV.x / TEXTURE_PIXEL_SIZE.x));
	int _PIXEL_Y = int(floor(UV.y / TEXTURE_PIXEL_SIZE.y));
	// the specific x and y pixel coordinates within screen
	int _SCREEN_PIXEL_X = int(floor(SCREEN_UV.x / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_PIXEL_Y = int(floor(SCREEN_UV.y / SCREEN_PIXEL_SIZE.y));
	
	// WARNING - Use these instead. This accounts for if this is a normal or post processing shader.
	// Size of a pixel for this canvas (ie 1/320x1/180)
	float PIXEL_SIZE_X = POST_PROCESSING ? SCREEN_PIXEL_SIZE.x : TEXTURE_PIXEL_SIZE.x;
	float PIXEL_SIZE_Y = POST_PROCESSING ? SCREEN_PIXEL_SIZE.y : TEXTURE_PIXEL_SIZE.y;
	// Size of the canvas in pixels. (ex 320x180)
	int SIZE_IN_PIXELS_X = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_X : _SIZE_IN_PIXELS_X;
	int SIZE_IN_PIXELS_Y = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_Y : _SIZE_IN_PIXELS_Y;
	// The specific XY coordinates of the current pixel.
	int X = POST_PROCESSING ? _SCREEN_PIXEL_X : _PIXEL_X;
	int Y = POST_PROCESSING ? _SCREEN_PIXEL_Y : _PIXEL_Y;
	// UV coordinates of the current pixel.
	vec2 MUV = POST_PROCESSING ? SCREEN_UV : UV;
	// ---
	
	
	// DISPLACE & PAN
	vec2 adjUV = vec2(0, 0); // WARNING - Use this instead of UV below, otherwise effects break with panning & displace
	
	float displaceUVX = MUV.x + (SCREEN_PIXEL_SIZE.x * float(displace_x));
	float displaceUVY = MUV.y + (SCREEN_PIXEL_SIZE.y * float(displace_y));
	if (displace_repeat) {
		adjUV = mod(vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed, 1.00000);
	} else {
		adjUV = vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed;
	}
	
	// $HACK$ doing this as a ternary breaks the preview, for some reason
	if (POST_PROCESSING) 
		COLOR = texture(SCREEN_TEXTURE, adjUV);
	else 
		COLOR = texture(TEXTURE, adjUV);
	
	// EXCLUDE COLORS
	bool is_exclude_color = use_exclude_colors && (vec3eq(COLOR.rgb, exclude_color1) || vec3eq(COLOR.rgb, exclude_color2) || vec3eq(COLOR.rgb, exclude_color3) || vec3eq(COLOR.rgb, exclude_color4));
	
	// RECOLOR
	if (vec3eq(COLOR.rgb, replace_color1)) 
		COLOR.rgb = replace_with_color1;
	if (vec3eq(COLOR.rgb, replace_color2)) 
		COLOR.rgb = replace_with_color2;
	if (vec3eq(COLOR.rgb, replace_color3)) 
		COLOR.rgb = replace_with_color3;
	if (vec3eq(COLOR.rgb, replace_color4)) 
		COLOR.rgb = replace_with_color4;
	if (vec3eq(COLOR.rgb, replace_color5)) 
		COLOR.rgb = replace_with_color5;
	if (vec3eq(COLOR.rgb, replace_color_outline))
		COLOR.rgb = replace_with_color_outline;
	
	// TINT, COLOR CORRECTION, and SCANLINE ignore excluded colors
	if (!is_exclude_color) {
		// TINT
		COLOR.rgb = mix(COLOR.rgb, tint_color, tint_strength);

		// FLASH
		// apply automatic flash
		if (auto_flash_speed != 0.0) {
			float auto_strength = mix(auto_flash_bound1, auto_flash_bound2, abs(vary0to1((TIME-auto_flash_start_time + TIME_OFFSET) * auto_flash_speed)));
			COLOR.rgb = mix(COLOR.rgb, auto_flash_color, auto_strength);
		}
		// apply manual flash
		COLOR.rgb = mix(COLOR.rgb, flash_color, flash_strength);

		// COLOR CORRECTION
		COLOR.r = mix(COLOR.r, 1.0, red_correct);
		COLOR.g = mix(COLOR.g, 1.0, green_correct);
		COLOR.b = mix(COLOR.b, 1.0, blue_correct);
		COLOR.rgb = mix(COLOR.rgb, vec3(0.2126 * COLOR.r + 0.7152 * COLOR.g + 0.0722 * COLOR.b), gray_correct);
		COLOR.rgb = mix(vec3(0.0), COLOR.rgb, brightness_correct);
		COLOR.rgb = mix(vec3(0.5), COLOR.rgb, contrast_correct);
		COLOR.rgb = mix(vec3(dot(vec3(1.0), COLOR.rbg)), COLOR.rgb, saturation_correct);

		// SCANLINE
		// FIX
		if (COLOR.a != 0.0) {
			float l_to_r_pos = !auto_scanline_left_to_right_on ? scanline_left_to_right_position : abs((auto_scanline_left_to_right_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_left_to_right_start_time + TIME_OFFSET, auto_scanline_left_to_right_delay + auto_scanline_left_to_right_scan_duration), 0.0, auto_scanline_left_to_right_scan_duration)/auto_scanline_left_to_right_scan_duration)));
			float t_to_b_pos = !auto_scanline_top_to_bottom_on ? scanline_top_to_bottom_position : abs((auto_scanline_top_to_bottom_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_top_to_bottom_start_time + TIME_OFFSET, auto_scanline_top_to_bottom_delay + auto_scanline_top_to_bottom_scan_duration), 0.0, auto_scanline_top_to_bottom_scan_duration)/auto_scanline_top_to_bottom_scan_duration)));
			float tl_to_br_pos = !auto_scanline_topleft_to_bottomright_on ? scanline_topleft_to_bottomright_position : abs((auto_scanline_topleft_to_bottomright_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topleft_to_bottomright_start_time + TIME_OFFSET, auto_scanline_topleft_to_bottomright_delay + auto_scanline_topleft_to_bottomright_scan_duration), 0.0, auto_scanline_topleft_to_bottomright_scan_duration)/auto_scanline_topleft_to_bottomright_scan_duration)));
			float tr_to_bl_pos = !auto_scanline_topright_to_bottomleft_on ? scanline_topright_to_bottomleft_position : abs((auto_scanline_topright_to_bottomleft_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topright_to_bottomleft_start_time + TIME_OFFSET, auto_scanline_topright_to_bottomleft_delay + auto_scanline_topright_to_bottomleft_scan_duration), 0.0, auto_scanline_topright_to_bottomleft_scan_duration)/auto_scanline_topright_to_bottomleft_scan_duration)));

			if (X == int(floor(l_to_r_pos / float(PIXEL_SIZE_X))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (Y == int(floor(t_to_b_pos / float(PIXEL_SIZE_Y))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			int scanline_target_tlbr = int(floor(tl_to_br_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y)));
			int scanline_target_trbl = int(floor(tr_to_bl_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y))) - SIZE_IN_PIXELS_Y;
			if (X+Y == scanline_target_tlbr)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (X-Y == scanline_target_trbl)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
		}
	}

	// GLOW
	if (glow_thickness != 0) {
		vec2 outline_size = TEXTURE_PIXEL_SIZE * float(glow_thickness);
		float outline = 0.0;
		for (int i = 0; i < HORIZONTAL_VERTICAL_OFFSETS.length(); i++) {
			outline += texture(TEXTURE, adjUV + outline_size * HORIZONTAL_VERTICAL_OFFSETS[i]).a;
		}
		if (glow_diagonals) {
			for (int i = 0; i < DIAGONAL_OUTLINE_OFFSETS.length(); i++) {
				outline += texture(TEXTURE, adjUV + outline_size * DIAGONAL_OUTLINE_OFFSETS[i]).a;
			}
		}
		outline = min(outline, 1.0);
		// this is a bit of a coding $HACK$ to make auto_glow_bound do nothing if auto_glow_speed is 0, but it definitely works
		float alp = auto_glow_speed == 0.0 ? 1.0 : mix(auto_glow_bound, glow_color.a, vary0to1((TIME - auto_glow_start_time + TIME_OFFSET) * auto_glow_speed));
		COLOR = mix(COLOR, glow_color * alp, outline - COLOR.a);
	}

	// DISINTEGRATE
	if (!is_exclude_color && COLOR.a != 0.0) {
		vec2 s = adjUV * vec2(float(disintegrate_seed));
		s *= auto_disintegrate_random_seed_speed != 0.0 ? float(int(TIME / mix(1.0, 0.001, auto_disintegrate_random_seed_speed))) : 1.0;
		float r = random(s);
		if (r < disintegrate_strength) {
			float r_alpha = randf_range(s, disintegrate_alpha_bound1, disintegrate_alpha_bound2);
			COLOR.rgb = mix(COLOR.rgb, disintegrate_color, r_alpha);
			if (!disintegrate_as_static)
				COLOR.a = r_alpha;
		}
	}

	// FOG
	if (fog_enabled) {
		vec2 fog_uv = MUV + fog_speed * TIME;
		float noise_alpha = texture(fog_noise_texture, fog_uv).r;
		// Convert noise from (0.0, 1.0) to (-1.0, 1.0)
		float fog = clamp((noise_alpha * 2.0 - 1.0) + (fog_density * 2.0), 0.0, 1.0);
		COLOR.a *= fog * fog_opacity;
	}

	// COLORLINES	
	if (!is_exclude_color) {
		if (X % vertical_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, vertical_colorline_color, vertical_colorline_strength);
		}
		if (Y % horizontal_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, horizontal_colorline_color, horizontal_colorline_strength);
		}
	}

	// CHECKER
	if (!is_exclude_color) {	
		if (X/checker_x_size % checker_x_pattern != Y/checker_y_size % checker_y_pattern) {
			float pixel_darkness = (3.0 - (COLOR.r + COLOR.g + COLOR.b)) * checker_contrast_ratio; // calculates 0.0 to 1.0 where 1.0 is pure black and 0.0 is pure white
			vec3 cbcolor = mix(checker_color.rgb, vec3(0.0), pixel_darkness * checker_contrast_amount);
			COLOR.rgb = mix(COLOR.rgb, cbcolor, checker_strength);
		}
	}

	// MOUSELIGHT
	if (mouselight_on && (!mouselight_checker || X % 2 == Y % 2)) {
		float mouse_with_flicker = mix(auto_mouselight_flicker_bound, float(mouselight_size), vary0to1(TIME * auto_mouselight_flicker_speed));
		float dist_from_mouse = sqrt(pow(float(_SCREEN_PIXEL_X - int(MOUSE.x)), 2.0) + pow(float(_SCREEN_PIXEL_Y - int(MOUSE.y)), 2.0));
		if (dist_from_mouse <= float(mouse_with_flicker)) {
			//todo - make softening with distance optional as uniform
			float distance_mod = clamp((mouse_with_flicker - dist_from_mouse) / mouse_with_flicker, 0.0, 1.0);
			COLOR.rgb = mix(COLOR.rgb, mouselight_color, distance_mod * mouselight_strength);
		}
	}

	// CUT
	if (MUV.x < cut_left)
		COLOR.a = 0.0;
	if (MUV.x > 1.0-cut_right)
		COLOR.a = 0.0;
	if (MUV.y < cut_top)
		COLOR.a = 0.0;
	if (MUV.y > 1.0-cut_bottom)
		COLOR.a = 0.0;

	// VIGNETTE
	if (vignette_on && ((!vignette_ignore_transparent || COLOR.a != 0.0)) && !is_exclude_color) {
		float x = abs(adjUV.x-.5)*2.0;
		float y = abs(adjUV.y-.5)*2.0;
		float v = (sqrt((x*x)+(y*y))/vignette_radius);
		COLOR = mix(COLOR, vec4(vignette_color.r, vignette_color.g, vignette_color.b, 1.0), v);
	}

	// TRANSPARENCY
	if (COLOR.a != 0.0) {
		COLOR.a = mix(COLOR.a * transparency, auto_flicker_bound, vary0to1((TIME-auto_flicker_start_time + TIME_OFFSET) * auto_flicker_speed));
	}
}

void vertex()
{
	
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_4n7hr"]
shader = SubResource("Shader_vl1yy")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(0.784314, 0.180392, 0.952941, 1)
shader_parameter/auto_flash_speed = 5.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 0.2
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="Shader" id="Shader_84del"]
code = "// Ben's Uber Pixel Shader
// WARNING - Shader expects uniform inputs in the range 0.0 - 1.0 for Colors. 
//           Therefore, be sure that Colors being passed in are in the correct range of (0-1, 0-1, 0-1, 0-1).
shader_type canvas_item;

// --- Utilty Functions --- //
const bool DEBUG = true;
const float TIME_OFFSET = 10.0; //offset all start times by this... for some reason things line up better with expectations
const vec2 HORIZONTAL_VERTICAL_OFFSETS[4] = {vec2(0, 1), vec2(-1, 0), vec2(1, 0), vec2(0, -1)};
const vec2 DIAGONAL_OUTLINE_OFFSETS[4] = {vec2(1, 1), vec2(-1, 1), vec2(1, -1), vec2(-1, -1)};

// checks if two values are 'equal' (within EPSILON of each other)
// necessary when doing float calculations since it's not perfectly precise
const float EPSILON = 0.001;
bool floateq(float val1, float val2) { return val1 >= val2 - EPSILON && val1 <= val2 + EPSILON; }
bool vec3eq(vec3 val1, vec3 val2) { return floateq(val1.r, val2.r) && floateq(val1.g, val2.g) && floateq(val1.b, val2.b); }

// Author: Michael Pohoreski https://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader
float random(vec2 seed){ return fract(cos(dot(seed, vec2(23.14069263277926, 2.665144142690225))) * 12345.6789); }
float snoise3(vec2 seed) { return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453); }
float randf_range(vec2 seed, float b1, float b2) { return mix(b1, b2, random(seed)); }
int randi_range(vec2 seed, int b1, int b2) { return int(randf_range(seed, float(b1), float(b2))); }
float sin0to1(float time) { return (sin(time)+1.0)/2.0; }
float cos0to1(float time) { return (cos(time)+1.0)/2.0; } 
float vary0to1(float time) { return 1.0-(cos(time)+1.0)/2.0; } // a transformed cos function that varies from 0 to 1. f(0) = 0, f(pi) = 1, f(2pi) = 0. 

uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;

uniform bool POST_PROCESSING = false;

// pass in the mouse position here
uniform vec2 MOUSE = vec2(20, 20);


// --- Effects --- //
// EXCLUDE
// If use_exclude_colors, pixels of these colors are excluded from tint, color correction, scanline, and vignette effects.
group_uniforms Exclude;
uniform bool use_exclude_colors = true;
uniform vec3 exclude_color1: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color2: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color3: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color4: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders

// PAN/DISPLACE
// Displaces all pixels by (displace_x, displace_y). Texture repeats if displace_repeat.
// WARNING - Offsetting beyond the bounds of the texture will result in the texture being cut off
group_uniforms PanAndDisplacement;
uniform int displace_x = 0;
uniform int displace_y = 0;
uniform bool displace_repeat = true;
// Texture will automatically scroll if auto_pan_speed is nonzero.
// Set auto_pan_speed to a positive number for left/up panning; negative number for right/down panning
// WARNING - Repeat generally should be true for auto_pan_speed, otherwise it will immediately pan out of view
uniform vec2 auto_pan_speed = vec2(0, 0);

// RECOLOR
// Replaces replace_colorN with replace_with_colorN.
group_uniforms Recolor;
uniform vec3 replace_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color5: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color5: source_color = vec3(0.0, 0.0, 0.0);

// special extra uniform specifically intended to recolor outlines
uniform vec3 replace_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 replace_with_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392);

// TINT
// Tint the texture with tint_color.
// The strength of the tint is controlled by tint_strength.
group_uniforms Tint;
uniform vec3 tint_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float tint_strength: hint_range(0.0, 1.0) = 0.0;

// FLASH
// Flash the texture with flash_color. Essentially, this is a second layer of tint.
// flash_strength controls how much color is the original and how much is the flash_color.
group_uniforms Flash;
uniform vec3 flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float flash_strength: hint_range(0.0, 1.0) = 0.0;
// auto_flash_speed will cause infinite and repeated flashing in auto_flash_color if nonzero and controls the speed of this flashing.
// auto_flash_bound1 and auto_flash_bound2 provide the bounds of the flashing effect.
// To prevent the auto flash from starting in the middle of the animation, set auto_flash_start_time to the global time when enabling auto flash.
// TIP - auto flash and regular ('manual') flash stack, which is why they have two separate colors.
uniform vec3 auto_flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float auto_flash_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flash_bound1: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flash_bound2: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flash_start_time = 0.0;

// COLOR CORRECTION
group_uniforms ColorCorrection;
// Applies red, green, or blue color correction with red_correct, green_correct, and blue_correct. 
// Applies grayscale with gray_correct.
// Modify brightness, contrast, or saturation with brightness_correct, contrast_correct, and saturation_correct.
// TIP - these values can actually go higher or lower, if you want a more extreme effect
uniform float red_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float green_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float blue_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float gray_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float brightness_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float contrast_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float saturation_correct: hint_range(0.0, 2.0, 0.01) = 1.0;

// TODO - more funky color options
// rg swap - swaps the original (before any other swaps) value of r and g
// gb swap
// br swap
// r_eq_g - sets r = g
// r_eq_b
// g_eq_r
// g_eq_b
// b_eq_r
// b_eq_g

// TODO - ROUGHEN - applies randomized brightness modifications across the texture (both positive and negative) to 'roughen' it up

// SCANLINES
// Create a line across the canvas of scanline_color. scanline_strength controls the alpha of the line.
// Define the position of the line with scanline_left_to_right_position, scanline_top_to_bottom_position,
// scanline_topleft_to_bottomright_position, and scanline_topright_to_bottomleft_position.
// The line is vertical if going left to right, horizontal if going top to bottom, and diagonal for the other two.
group_uniforms Scanline;
uniform vec3 scanline_color: source_color = vec3(0.98, 0.69, 0.23);
uniform float scanline_strength: hint_range(0.0, 1.0, 0.01) = 1.0;
uniform float scanline_left_to_right_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_top_to_bottom_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topleft_to_bottomright_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topright_to_bottomleft_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
// auto_scanline_DIRECTION_on will enable automatic repeating scanlines in that direction.
// auto_scanline_DIRECTION_reverse will flip the direction.
// The scan will be visible for auto_scanline_DIRECTION_scan_duration, with a delay of 
// auto_scanline_DIRECTION_scan_duration before the next scan begins.
// To prevent the scanline from starting in the middle of the texture, provide the global time to auto_scanline_DIRECTION_start_time.
uniform bool auto_scanline_left_to_right_on = false;
uniform bool auto_scanline_left_to_right_reverse = false;
uniform float auto_scanline_left_to_right_start_time = 0.0;
uniform float auto_scanline_left_to_right_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_left_to_right_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_top_to_bottom_on = false;
uniform bool auto_scanline_top_to_bottom_reverse = false;
uniform float auto_scanline_top_to_bottom_start_time = 0.0;
uniform float auto_scanline_top_to_bottom_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_top_to_bottom_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topleft_to_bottomright_on = false;
uniform bool auto_scanline_topleft_to_bottomright_reverse = false;
uniform float auto_scanline_topleft_to_bottomright_start_time = 0.0;
uniform float auto_scanline_topleft_to_bottomright_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topleft_to_bottomright_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topright_to_bottomleft_on = false;
uniform bool auto_scanline_topright_to_bottomleft_reverse = false;
uniform float auto_scanline_topright_to_bottomleft_start_time = 0.0;
uniform float auto_scanline_topright_to_bottomleft_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topright_to_bottomleft_delay: hint_range(0.0, 10.0, 0.01) = 1.0;

// OUTLINE
// Adds a pixel outline to the texture, with glow_color and glow_thickness.
// glow_dialgonals controls if we also create this outline diagonally, which makes it thicker.
// This can be used to create a solid outline if auto_glow_speed is left at 0.
// WARNING - Shaders cannot draw outside of the bounds of the canvas, so the canvas may need extra transparent space on the sides.
// WARNING - Can have some odd effects with sprites containing partial transparency.
group_uniforms GlowAndOutline;
uniform vec4 glow_color: source_color = vec4(1.0);
uniform int glow_thickness: hint_range(0, 10) = 0;
uniform bool glow_diagonals = false;
// auto_glow_speed defines the speed of a glow fluctuating alpha between the outline's alpha and auto_glow_bound at auto_glow_speed.
// To prevent the auto glow from starting in the middle of the animation, set auto_glow_start_time to the global time when enabling auto glow.
uniform float auto_glow_speed: hint_range(0.0, 30.0) = 0.0;
uniform float auto_glow_bound: hint_range(0.0, 1.0) = 0.75;
uniform float auto_glow_start_time = 0.0;

// DISINTEGRATE
// Sets 'random' pixels in the canvas to disintegrate_color with alpha between disintegrate_alpha_bound1 and disintegrate_alpha_bound2.
// By default, since these bounds are 0, the pixels will be made fully transparent and therefore disintegrate_color is unused.
// disintegrate_strength controls the amount of pixels affected, from none (0) to all of them (1).
// Change the pattern via disintegrate_seed.
// disintegrate_as_static changes the purpose of disintegrate to not affect the alpha of the texture.
// Instead, it layers a static-looking pattern on top using disintegrate_color, where the color is based on disintegrate_color
// and the alpha of the static pattern ranges randomly between disintegrate_alpha_bound1 and disintegrate_alpha_bound2 per pixel.
// Note that with the default bounds of 0 and 0, this setting creates no effect whatsoever.
// If auto_disintegrate_random_seed_speed is nonzero, applies randomization to the seed over time based on speed.
// In this case, disintegrate_seed has no effect.
group_uniforms Disintegrate;
uniform int disintegrate_seed = 1;
uniform vec3 disintegrate_color : source_color = vec3(0.0, 0.0, 0.0);
uniform float disintegrate_strength: hint_range(0.0, 1.0) = 0.0;
uniform float disintegrate_alpha_bound1 = 0.0;
uniform float disintegrate_alpha_bound2 = 0.0;
uniform bool disintegrate_as_static = false;
uniform float auto_disintegrate_random_seed_speed: hint_range(0.0, 1.0) = 0.0;

// FOG
// Applies a fog_noise_texture filter over the texture with modifiable fog_opacity and fog_density, moving at fog_speed
// Mostly used to create fog effects by assigning to a ColorRect (color is changable by changing ColorRect color too!)
// NOTE - Don't use this as a post processing shader. 
group_uniforms Fog;
uniform bool fog_enabled = false;
uniform sampler2D fog_noise_texture: repeat_enable, filter_nearest;
uniform float fog_opacity: hint_range(0.0, 1.0) = 0.5;
uniform float fog_density: hint_range(0.0, 1.0) = 0.25;
uniform vec2 fog_speed = vec2(-0.02, 0.0);

// COLORLINES
// Creates vertical/horizontal lines of colorline_color spaced colorline_spacing pixels apart 
// with colorline_strength alpha across the texture.
group_uniforms Colorlines;
uniform vec3 vertical_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int vertical_colorline_spacing = 2;
uniform float vertical_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;
uniform vec3 horizontal_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int horizontal_colorline_spacing = 2;
uniform float horizontal_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;

// CHECKER
// Creates a checkerboard pattern across the texture of checker_color with checker_strength alpha.
// checker_x_size and checker_y_size defines the size of each rectangular checker
// checker_x_pattern and checker_y_pattern affect the pattern of the checker pattern (which
// can stop looking checkered with different values).
// checker_contrast_amount applies a darkening effect to pixels of the checkerboard that are already dark.
// checker_contrast_ratio increases the contrast of the darkening effect between light and dark colored pixels,
// ie dark pixels become even darker.
group_uniforms CHECKER;
uniform vec3 checker_color: source_color = vec3(0.2, 0.2, 0.2);
uniform float checker_strength: hint_range(0.0, 1.0, 0.01) = 0.0; //0.3 is a good one
uniform int checker_x_size: hint_range(1, 64, 1) = 1;
uniform int checker_y_size: hint_range(1, 64, 1) = 1;
uniform int checker_x_pattern: hint_range(1, 32, 1) = 2;
uniform int checker_y_pattern: hint_range(1, 32, 1) = 2;
uniform float checker_contrast_amount: hint_range(-10.0, 10.0, 0.1) = 1.0;
uniform float checker_contrast_ratio: hint_range(0.0, 10.0, 0.01) = 0.5;
// TODO - experiment a bit more with the contrast calculation here - maybe subtract 0.5 and LIGHTEN lighter areas?

// MOUSELIGHT
// Creates a circular lighting effect at the mouse's position if mouselight_on, of mouselight_color and mouselight_strength alpha.
// Mouselight size defines the radius of the light effect.
// If mouselight_soften_edges, pixels further from the center of the light are more transparent.
// If mouselight_checker, the effect will be checkered in a way that interacts with the CHECKER effect.
// If auto_mouselight_flicker_speed is non-zero, the light will oscillate in size between mouselight_size and auto_mouselight_flicker_speed
group_uniforms Mouselight;
uniform bool mouselight_on = false;
uniform vec3 mouselight_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float mouselight_strength = 0.5;
uniform int mouselight_size = 8;
uniform bool mouselight_soften_edges = true;
uniform bool mouselight_checker = false;
uniform float auto_mouselight_flicker_speed: hint_range(0.0, 20.0) = 8;
uniform float auto_mouselight_flicker_bound = 10;

// CUT
// Cuts off all pixels of the texture from left/right/top/bottom.
group_uniforms Cut;
uniform float cut_left: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_right: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_top: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_bottom: hint_range(0.0, 1.0, 0.001) = 0.0;

// VIGNETTE
// Applies a circular vignette effect on the canvas if vignette_on.
// The vignette has a vignette_radius and a vignette_color.
// If vignette_ignore_transparent, transparent pixels will not have the vignette applied.
// This is generally useful if you want to apply a vignette on something besides the entire screen.
// Radius -> 0 tends to do some crazy effects
group_uniforms Vignette;
uniform bool vignette_on = false;
uniform bool vignette_ignore_transparent = false;
uniform vec3 vignette_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float vignette_radius: hint_range(0.001, 20.0, 0.01) = 1.0;

// TRANSPARENCY
// Controls transparency of the texture.
// If auto_flicker_speed is not zero, oscillates between transparency and auto_flicker_bounds at auto_flicker_speed.
// To prevent the auto flicker from starting in the middle of the animation, set auto_flicker_start_time to the global time when enabling auto flicker.
group_uniforms Transparency;
uniform float transparency: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flicker_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flicker_bound: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flicker_start_time = 0.0;

// --- Fragment Shader --- //
void fragment() 
{
	COLOR = texture(TEXTURE, UV);
	
	// --- CALCULATE CONSTANTS ---
	// WARNING - Don't use the ones with _ directly. 
	// the size of this canvas in pixels (ex 10x10)
	int _SIZE_IN_PIXELS_X = int(floor(1.0 / TEXTURE_PIXEL_SIZE.x));
	int _SIZE_IN_PIXELS_Y = int(floor(1.0 / TEXTURE_PIXEL_SIZE.y));
	// the size of the screen in pixels (ex 320x180)
	int _SCREEN_SIZE_IN_PIXELS_X = int(floor(1.0 / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_SIZE_IN_PIXELS_Y = int(floor(1.0 / SCREEN_PIXEL_SIZE.y));
	
	// the specific x and y pixel coordinates within texture
	int _PIXEL_X = int(floor(UV.x / TEXTURE_PIXEL_SIZE.x));
	int _PIXEL_Y = int(floor(UV.y / TEXTURE_PIXEL_SIZE.y));
	// the specific x and y pixel coordinates within screen
	int _SCREEN_PIXEL_X = int(floor(SCREEN_UV.x / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_PIXEL_Y = int(floor(SCREEN_UV.y / SCREEN_PIXEL_SIZE.y));
	
	// WARNING - Use these instead. This accounts for if this is a normal or post processing shader.
	// Size of a pixel for this canvas (ie 1/320x1/180)
	float PIXEL_SIZE_X = POST_PROCESSING ? SCREEN_PIXEL_SIZE.x : TEXTURE_PIXEL_SIZE.x;
	float PIXEL_SIZE_Y = POST_PROCESSING ? SCREEN_PIXEL_SIZE.y : TEXTURE_PIXEL_SIZE.y;
	// Size of the canvas in pixels. (ex 320x180)
	int SIZE_IN_PIXELS_X = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_X : _SIZE_IN_PIXELS_X;
	int SIZE_IN_PIXELS_Y = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_Y : _SIZE_IN_PIXELS_Y;
	// The specific XY coordinates of the current pixel.
	int X = POST_PROCESSING ? _SCREEN_PIXEL_X : _PIXEL_X;
	int Y = POST_PROCESSING ? _SCREEN_PIXEL_Y : _PIXEL_Y;
	// UV coordinates of the current pixel.
	vec2 MUV = POST_PROCESSING ? SCREEN_UV : UV;
	// ---
	
	
	// DISPLACE & PAN
	vec2 adjUV = vec2(0, 0); // WARNING - Use this instead of UV below, otherwise effects break with panning & displace
	
	float displaceUVX = MUV.x + (SCREEN_PIXEL_SIZE.x * float(displace_x));
	float displaceUVY = MUV.y + (SCREEN_PIXEL_SIZE.y * float(displace_y));
	if (displace_repeat) {
		adjUV = mod(vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed, 1.00000);
	} else {
		adjUV = vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed;
	}
	
	// $HACK$ doing this as a ternary breaks the preview, for some reason
	if (POST_PROCESSING) 
		COLOR = texture(SCREEN_TEXTURE, adjUV);
	else 
		COLOR = texture(TEXTURE, adjUV);
	
	// EXCLUDE COLORS
	bool is_exclude_color = use_exclude_colors && (vec3eq(COLOR.rgb, exclude_color1) || vec3eq(COLOR.rgb, exclude_color2) || vec3eq(COLOR.rgb, exclude_color3) || vec3eq(COLOR.rgb, exclude_color4));
	
	// RECOLOR
	if (vec3eq(COLOR.rgb, replace_color1)) 
		COLOR.rgb = replace_with_color1;
	if (vec3eq(COLOR.rgb, replace_color2)) 
		COLOR.rgb = replace_with_color2;
	if (vec3eq(COLOR.rgb, replace_color3)) 
		COLOR.rgb = replace_with_color3;
	if (vec3eq(COLOR.rgb, replace_color4)) 
		COLOR.rgb = replace_with_color4;
	if (vec3eq(COLOR.rgb, replace_color5)) 
		COLOR.rgb = replace_with_color5;
	if (vec3eq(COLOR.rgb, replace_color_outline))
		COLOR.rgb = replace_with_color_outline;
	
	// TINT, COLOR CORRECTION, and SCANLINE ignore excluded colors
	if (!is_exclude_color) {
		// TINT
		COLOR.rgb = mix(COLOR.rgb, tint_color, tint_strength);

		// FLASH
		// apply automatic flash
		if (auto_flash_speed != 0.0) {
			float auto_strength = mix(auto_flash_bound1, auto_flash_bound2, abs(vary0to1((TIME-auto_flash_start_time + TIME_OFFSET) * auto_flash_speed)));
			COLOR.rgb = mix(COLOR.rgb, auto_flash_color, auto_strength);
		}
		// apply manual flash
		COLOR.rgb = mix(COLOR.rgb, flash_color, flash_strength);

		// COLOR CORRECTION
		COLOR.r = mix(COLOR.r, 1.0, red_correct);
		COLOR.g = mix(COLOR.g, 1.0, green_correct);
		COLOR.b = mix(COLOR.b, 1.0, blue_correct);
		COLOR.rgb = mix(COLOR.rgb, vec3(0.2126 * COLOR.r + 0.7152 * COLOR.g + 0.0722 * COLOR.b), gray_correct);
		COLOR.rgb = mix(vec3(0.0), COLOR.rgb, brightness_correct);
		COLOR.rgb = mix(vec3(0.5), COLOR.rgb, contrast_correct);
		COLOR.rgb = mix(vec3(dot(vec3(1.0), COLOR.rbg)), COLOR.rgb, saturation_correct);

		// SCANLINE
		// FIX
		if (COLOR.a != 0.0) {
			float l_to_r_pos = !auto_scanline_left_to_right_on ? scanline_left_to_right_position : abs((auto_scanline_left_to_right_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_left_to_right_start_time + TIME_OFFSET, auto_scanline_left_to_right_delay + auto_scanline_left_to_right_scan_duration), 0.0, auto_scanline_left_to_right_scan_duration)/auto_scanline_left_to_right_scan_duration)));
			float t_to_b_pos = !auto_scanline_top_to_bottom_on ? scanline_top_to_bottom_position : abs((auto_scanline_top_to_bottom_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_top_to_bottom_start_time + TIME_OFFSET, auto_scanline_top_to_bottom_delay + auto_scanline_top_to_bottom_scan_duration), 0.0, auto_scanline_top_to_bottom_scan_duration)/auto_scanline_top_to_bottom_scan_duration)));
			float tl_to_br_pos = !auto_scanline_topleft_to_bottomright_on ? scanline_topleft_to_bottomright_position : abs((auto_scanline_topleft_to_bottomright_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topleft_to_bottomright_start_time + TIME_OFFSET, auto_scanline_topleft_to_bottomright_delay + auto_scanline_topleft_to_bottomright_scan_duration), 0.0, auto_scanline_topleft_to_bottomright_scan_duration)/auto_scanline_topleft_to_bottomright_scan_duration)));
			float tr_to_bl_pos = !auto_scanline_topright_to_bottomleft_on ? scanline_topright_to_bottomleft_position : abs((auto_scanline_topright_to_bottomleft_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topright_to_bottomleft_start_time + TIME_OFFSET, auto_scanline_topright_to_bottomleft_delay + auto_scanline_topright_to_bottomleft_scan_duration), 0.0, auto_scanline_topright_to_bottomleft_scan_duration)/auto_scanline_topright_to_bottomleft_scan_duration)));

			if (X == int(floor(l_to_r_pos / float(PIXEL_SIZE_X))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (Y == int(floor(t_to_b_pos / float(PIXEL_SIZE_Y))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			int scanline_target_tlbr = int(floor(tl_to_br_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y)));
			int scanline_target_trbl = int(floor(tr_to_bl_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y))) - SIZE_IN_PIXELS_Y;
			if (X+Y == scanline_target_tlbr)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (X-Y == scanline_target_trbl)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
		}
	}

	// GLOW
	if (glow_thickness != 0) {
		vec2 outline_size = TEXTURE_PIXEL_SIZE * float(glow_thickness);
		float outline = 0.0;
		for (int i = 0; i < HORIZONTAL_VERTICAL_OFFSETS.length(); i++) {
			outline += texture(TEXTURE, adjUV + outline_size * HORIZONTAL_VERTICAL_OFFSETS[i]).a;
		}
		if (glow_diagonals) {
			for (int i = 0; i < DIAGONAL_OUTLINE_OFFSETS.length(); i++) {
				outline += texture(TEXTURE, adjUV + outline_size * DIAGONAL_OUTLINE_OFFSETS[i]).a;
			}
		}
		outline = min(outline, 1.0);
		// this is a bit of a coding $HACK$ to make auto_glow_bound do nothing if auto_glow_speed is 0, but it definitely works
		float alp = auto_glow_speed == 0.0 ? 1.0 : mix(auto_glow_bound, glow_color.a, vary0to1((TIME - auto_glow_start_time + TIME_OFFSET) * auto_glow_speed));
		COLOR = mix(COLOR, glow_color * alp, outline - COLOR.a);
	}

	// DISINTEGRATE
	if (!is_exclude_color && COLOR.a != 0.0) {
		vec2 s = adjUV * vec2(float(disintegrate_seed));
		s *= auto_disintegrate_random_seed_speed != 0.0 ? float(int(TIME / mix(1.0, 0.001, auto_disintegrate_random_seed_speed))) : 1.0;
		float r = random(s);
		if (r < disintegrate_strength) {
			float r_alpha = randf_range(s, disintegrate_alpha_bound1, disintegrate_alpha_bound2);
			COLOR.rgb = mix(COLOR.rgb, disintegrate_color, r_alpha);
			if (!disintegrate_as_static)
				COLOR.a = r_alpha;
		}
	}

	// FOG
	if (fog_enabled) {
		vec2 fog_uv = MUV + fog_speed * TIME;
		float noise_alpha = texture(fog_noise_texture, fog_uv).r;
		// Convert noise from (0.0, 1.0) to (-1.0, 1.0)
		float fog = clamp((noise_alpha * 2.0 - 1.0) + (fog_density * 2.0), 0.0, 1.0);
		COLOR.a *= fog * fog_opacity;
	}

	// COLORLINES	
	if (!is_exclude_color) {
		if (X % vertical_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, vertical_colorline_color, vertical_colorline_strength);
		}
		if (Y % horizontal_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, horizontal_colorline_color, horizontal_colorline_strength);
		}
	}

	// CHECKER
	if (!is_exclude_color) {	
		if (X/checker_x_size % checker_x_pattern != Y/checker_y_size % checker_y_pattern) {
			float pixel_darkness = (3.0 - (COLOR.r + COLOR.g + COLOR.b)) * checker_contrast_ratio; // calculates 0.0 to 1.0 where 1.0 is pure black and 0.0 is pure white
			vec3 cbcolor = mix(checker_color.rgb, vec3(0.0), pixel_darkness * checker_contrast_amount);
			COLOR.rgb = mix(COLOR.rgb, cbcolor, checker_strength);
		}
	}

	// MOUSELIGHT
	if (mouselight_on && (!mouselight_checker || X % 2 == Y % 2)) {
		float mouse_with_flicker = mix(auto_mouselight_flicker_bound, float(mouselight_size), vary0to1(TIME * auto_mouselight_flicker_speed));
		float dist_from_mouse = sqrt(pow(float(_SCREEN_PIXEL_X - int(MOUSE.x)), 2.0) + pow(float(_SCREEN_PIXEL_Y - int(MOUSE.y)), 2.0));
		if (dist_from_mouse <= float(mouse_with_flicker)) {
			//todo - make softening with distance optional as uniform
			float distance_mod = clamp((mouse_with_flicker - dist_from_mouse) / mouse_with_flicker, 0.0, 1.0);
			COLOR.rgb = mix(COLOR.rgb, mouselight_color, distance_mod * mouselight_strength);
		}
	}

	// CUT
	if (MUV.x < cut_left)
		COLOR.a = 0.0;
	if (MUV.x > 1.0-cut_right)
		COLOR.a = 0.0;
	if (MUV.y < cut_top)
		COLOR.a = 0.0;
	if (MUV.y > 1.0-cut_bottom)
		COLOR.a = 0.0;

	// VIGNETTE
	if (vignette_on && ((!vignette_ignore_transparent || COLOR.a != 0.0)) && !is_exclude_color) {
		float x = abs(adjUV.x-.5)*2.0;
		float y = abs(adjUV.y-.5)*2.0;
		float v = (sqrt((x*x)+(y*y))/vignette_radius);
		COLOR = mix(COLOR, vec4(vignette_color.r, vignette_color.g, vignette_color.b, 1.0), v);
	}

	// TRANSPARENCY
	if (COLOR.a != 0.0) {
		COLOR.a = mix(COLOR.a * transparency, auto_flicker_bound, vary0to1((TIME-auto_flicker_start_time + TIME_OFFSET) * auto_flicker_speed));
	}
}

void vertex()
{
	
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_tw3c5"]
shader = SubResource("Shader_84del")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(0.360784, 0.552941, 0.741176, 1)
shader_parameter/auto_flash_speed = 5.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 0.2
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="Shader" id="Shader_sl100"]
code = "// Ben's Uber Pixel Shader
// WARNING - Shader expects uniform inputs in the range 0.0 - 1.0 for Colors. 
//           Therefore, be sure that Colors being passed in are in the correct range of (0-1, 0-1, 0-1, 0-1).
shader_type canvas_item;

// --- Utilty Functions --- //
const bool DEBUG = true;
const float TIME_OFFSET = 10.0; //offset all start times by this... for some reason things line up better with expectations
const vec2 HORIZONTAL_VERTICAL_OFFSETS[4] = {vec2(0, 1), vec2(-1, 0), vec2(1, 0), vec2(0, -1)};
const vec2 DIAGONAL_OUTLINE_OFFSETS[4] = {vec2(1, 1), vec2(-1, 1), vec2(1, -1), vec2(-1, -1)};

// checks if two values are 'equal' (within EPSILON of each other)
// necessary when doing float calculations since it's not perfectly precise
const float EPSILON = 0.001;
bool floateq(float val1, float val2) { return val1 >= val2 - EPSILON && val1 <= val2 + EPSILON; }
bool vec3eq(vec3 val1, vec3 val2) { return floateq(val1.r, val2.r) && floateq(val1.g, val2.g) && floateq(val1.b, val2.b); }

// Author: Michael Pohoreski https://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader
float random(vec2 seed){ return fract(cos(dot(seed, vec2(23.14069263277926, 2.665144142690225))) * 12345.6789); }
float snoise3(vec2 seed) { return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453); }
float randf_range(vec2 seed, float b1, float b2) { return mix(b1, b2, random(seed)); }
int randi_range(vec2 seed, int b1, int b2) { return int(randf_range(seed, float(b1), float(b2))); }
float sin0to1(float time) { return (sin(time)+1.0)/2.0; }
float cos0to1(float time) { return (cos(time)+1.0)/2.0; } 
float vary0to1(float time) { return 1.0-(cos(time)+1.0)/2.0; } // a transformed cos function that varies from 0 to 1. f(0) = 0, f(pi) = 1, f(2pi) = 0. 

uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;

uniform bool POST_PROCESSING = false;

// pass in the mouse position here
uniform vec2 MOUSE = vec2(20, 20);


// --- Effects --- //
// EXCLUDE
// If use_exclude_colors, pixels of these colors are excluded from tint, color correction, scanline, and vignette effects.
group_uniforms Exclude;
uniform bool use_exclude_colors = true;
uniform vec3 exclude_color1: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color2: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color3: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color4: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders

// PAN/DISPLACE
// Displaces all pixels by (displace_x, displace_y). Texture repeats if displace_repeat.
// WARNING - Offsetting beyond the bounds of the texture will result in the texture being cut off
group_uniforms PanAndDisplacement;
uniform int displace_x = 0;
uniform int displace_y = 0;
uniform bool displace_repeat = true;
// Texture will automatically scroll if auto_pan_speed is nonzero.
// Set auto_pan_speed to a positive number for left/up panning; negative number for right/down panning
// WARNING - Repeat generally should be true for auto_pan_speed, otherwise it will immediately pan out of view
uniform vec2 auto_pan_speed = vec2(0, 0);

// RECOLOR
// Replaces replace_colorN with replace_with_colorN.
group_uniforms Recolor;
uniform vec3 replace_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color5: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color5: source_color = vec3(0.0, 0.0, 0.0);

// special extra uniform specifically intended to recolor outlines
uniform vec3 replace_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 replace_with_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392);

// TINT
// Tint the texture with tint_color.
// The strength of the tint is controlled by tint_strength.
group_uniforms Tint;
uniform vec3 tint_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float tint_strength: hint_range(0.0, 1.0) = 0.0;

// FLASH
// Flash the texture with flash_color. Essentially, this is a second layer of tint.
// flash_strength controls how much color is the original and how much is the flash_color.
group_uniforms Flash;
uniform vec3 flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float flash_strength: hint_range(0.0, 1.0) = 0.0;
// auto_flash_speed will cause infinite and repeated flashing in auto_flash_color if nonzero and controls the speed of this flashing.
// auto_flash_bound1 and auto_flash_bound2 provide the bounds of the flashing effect.
// To prevent the auto flash from starting in the middle of the animation, set auto_flash_start_time to the global time when enabling auto flash.
// TIP - auto flash and regular ('manual') flash stack, which is why they have two separate colors.
uniform vec3 auto_flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float auto_flash_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flash_bound1: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flash_bound2: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flash_start_time = 0.0;

// COLOR CORRECTION
group_uniforms ColorCorrection;
// Applies red, green, or blue color correction with red_correct, green_correct, and blue_correct. 
// Applies grayscale with gray_correct.
// Modify brightness, contrast, or saturation with brightness_correct, contrast_correct, and saturation_correct.
// TIP - these values can actually go higher or lower, if you want a more extreme effect
uniform float red_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float green_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float blue_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float gray_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float brightness_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float contrast_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float saturation_correct: hint_range(0.0, 2.0, 0.01) = 1.0;

// TODO - more funky color options
// rg swap - swaps the original (before any other swaps) value of r and g
// gb swap
// br swap
// r_eq_g - sets r = g
// r_eq_b
// g_eq_r
// g_eq_b
// b_eq_r
// b_eq_g

// TODO - ROUGHEN - applies randomized brightness modifications across the texture (both positive and negative) to 'roughen' it up

// SCANLINES
// Create a line across the canvas of scanline_color. scanline_strength controls the alpha of the line.
// Define the position of the line with scanline_left_to_right_position, scanline_top_to_bottom_position,
// scanline_topleft_to_bottomright_position, and scanline_topright_to_bottomleft_position.
// The line is vertical if going left to right, horizontal if going top to bottom, and diagonal for the other two.
group_uniforms Scanline;
uniform vec3 scanline_color: source_color = vec3(0.98, 0.69, 0.23);
uniform float scanline_strength: hint_range(0.0, 1.0, 0.01) = 1.0;
uniform float scanline_left_to_right_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_top_to_bottom_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topleft_to_bottomright_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topright_to_bottomleft_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
// auto_scanline_DIRECTION_on will enable automatic repeating scanlines in that direction.
// auto_scanline_DIRECTION_reverse will flip the direction.
// The scan will be visible for auto_scanline_DIRECTION_scan_duration, with a delay of 
// auto_scanline_DIRECTION_scan_duration before the next scan begins.
// To prevent the scanline from starting in the middle of the texture, provide the global time to auto_scanline_DIRECTION_start_time.
uniform bool auto_scanline_left_to_right_on = false;
uniform bool auto_scanline_left_to_right_reverse = false;
uniform float auto_scanline_left_to_right_start_time = 0.0;
uniform float auto_scanline_left_to_right_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_left_to_right_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_top_to_bottom_on = false;
uniform bool auto_scanline_top_to_bottom_reverse = false;
uniform float auto_scanline_top_to_bottom_start_time = 0.0;
uniform float auto_scanline_top_to_bottom_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_top_to_bottom_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topleft_to_bottomright_on = false;
uniform bool auto_scanline_topleft_to_bottomright_reverse = false;
uniform float auto_scanline_topleft_to_bottomright_start_time = 0.0;
uniform float auto_scanline_topleft_to_bottomright_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topleft_to_bottomright_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topright_to_bottomleft_on = false;
uniform bool auto_scanline_topright_to_bottomleft_reverse = false;
uniform float auto_scanline_topright_to_bottomleft_start_time = 0.0;
uniform float auto_scanline_topright_to_bottomleft_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topright_to_bottomleft_delay: hint_range(0.0, 10.0, 0.01) = 1.0;

// OUTLINE
// Adds a pixel outline to the texture, with glow_color and glow_thickness.
// glow_dialgonals controls if we also create this outline diagonally, which makes it thicker.
// This can be used to create a solid outline if auto_glow_speed is left at 0.
// WARNING - Shaders cannot draw outside of the bounds of the canvas, so the canvas may need extra transparent space on the sides.
// WARNING - Can have some odd effects with sprites containing partial transparency.
group_uniforms GlowAndOutline;
uniform vec4 glow_color: source_color = vec4(1.0);
uniform int glow_thickness: hint_range(0, 10) = 0;
uniform bool glow_diagonals = false;
// auto_glow_speed defines the speed of a glow fluctuating alpha between the outline's alpha and auto_glow_bound at auto_glow_speed.
// To prevent the auto glow from starting in the middle of the animation, set auto_glow_start_time to the global time when enabling auto glow.
uniform float auto_glow_speed: hint_range(0.0, 30.0) = 0.0;
uniform float auto_glow_bound: hint_range(0.0, 1.0) = 0.75;
uniform float auto_glow_start_time = 0.0;

// DISINTEGRATE
// Sets 'random' pixels in the canvas to disintegrate_color with alpha between disintegrate_alpha_bound1 and disintegrate_alpha_bound2.
// By default, since these bounds are 0, the pixels will be made fully transparent and therefore disintegrate_color is unused.
// disintegrate_strength controls the amount of pixels affected, from none (0) to all of them (1).
// Change the pattern via disintegrate_seed.
// disintegrate_as_static changes the purpose of disintegrate to not affect the alpha of the texture.
// Instead, it layers a static-looking pattern on top using disintegrate_color, where the color is based on disintegrate_color
// and the alpha of the static pattern ranges randomly between disintegrate_alpha_bound1 and disintegrate_alpha_bound2 per pixel.
// Note that with the default bounds of 0 and 0, this setting creates no effect whatsoever.
// If auto_disintegrate_random_seed_speed is nonzero, applies randomization to the seed over time based on speed.
// In this case, disintegrate_seed has no effect.
group_uniforms Disintegrate;
uniform int disintegrate_seed = 1;
uniform vec3 disintegrate_color : source_color = vec3(0.0, 0.0, 0.0);
uniform float disintegrate_strength: hint_range(0.0, 1.0) = 0.0;
uniform float disintegrate_alpha_bound1 = 0.0;
uniform float disintegrate_alpha_bound2 = 0.0;
uniform bool disintegrate_as_static = false;
uniform float auto_disintegrate_random_seed_speed: hint_range(0.0, 1.0) = 0.0;

// FOG
// Applies a fog_noise_texture filter over the texture with modifiable fog_opacity and fog_density, moving at fog_speed
// Mostly used to create fog effects by assigning to a ColorRect (color is changable by changing ColorRect color too!)
// NOTE - Don't use this as a post processing shader. 
group_uniforms Fog;
uniform bool fog_enabled = false;
uniform sampler2D fog_noise_texture: repeat_enable, filter_nearest;
uniform float fog_opacity: hint_range(0.0, 1.0) = 0.5;
uniform float fog_density: hint_range(0.0, 1.0) = 0.25;
uniform vec2 fog_speed = vec2(-0.02, 0.0);

// COLORLINES
// Creates vertical/horizontal lines of colorline_color spaced colorline_spacing pixels apart 
// with colorline_strength alpha across the texture.
group_uniforms Colorlines;
uniform vec3 vertical_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int vertical_colorline_spacing = 2;
uniform float vertical_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;
uniform vec3 horizontal_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int horizontal_colorline_spacing = 2;
uniform float horizontal_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;

// CHECKER
// Creates a checkerboard pattern across the texture of checker_color with checker_strength alpha.
// checker_x_size and checker_y_size defines the size of each rectangular checker
// checker_x_pattern and checker_y_pattern affect the pattern of the checker pattern (which
// can stop looking checkered with different values).
// checker_contrast_amount applies a darkening effect to pixels of the checkerboard that are already dark.
// checker_contrast_ratio increases the contrast of the darkening effect between light and dark colored pixels,
// ie dark pixels become even darker.
group_uniforms CHECKER;
uniform vec3 checker_color: source_color = vec3(0.2, 0.2, 0.2);
uniform float checker_strength: hint_range(0.0, 1.0, 0.01) = 0.0; //0.3 is a good one
uniform int checker_x_size: hint_range(1, 64, 1) = 1;
uniform int checker_y_size: hint_range(1, 64, 1) = 1;
uniform int checker_x_pattern: hint_range(1, 32, 1) = 2;
uniform int checker_y_pattern: hint_range(1, 32, 1) = 2;
uniform float checker_contrast_amount: hint_range(-10.0, 10.0, 0.1) = 1.0;
uniform float checker_contrast_ratio: hint_range(0.0, 10.0, 0.01) = 0.5;
// TODO - experiment a bit more with the contrast calculation here - maybe subtract 0.5 and LIGHTEN lighter areas?

// MOUSELIGHT
// Creates a circular lighting effect at the mouse's position if mouselight_on, of mouselight_color and mouselight_strength alpha.
// Mouselight size defines the radius of the light effect.
// If mouselight_soften_edges, pixels further from the center of the light are more transparent.
// If mouselight_checker, the effect will be checkered in a way that interacts with the CHECKER effect.
// If auto_mouselight_flicker_speed is non-zero, the light will oscillate in size between mouselight_size and auto_mouselight_flicker_speed
group_uniforms Mouselight;
uniform bool mouselight_on = false;
uniform vec3 mouselight_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float mouselight_strength = 0.5;
uniform int mouselight_size = 8;
uniform bool mouselight_soften_edges = true;
uniform bool mouselight_checker = false;
uniform float auto_mouselight_flicker_speed: hint_range(0.0, 20.0) = 8;
uniform float auto_mouselight_flicker_bound = 10;

// CUT
// Cuts off all pixels of the texture from left/right/top/bottom.
group_uniforms Cut;
uniform float cut_left: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_right: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_top: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_bottom: hint_range(0.0, 1.0, 0.001) = 0.0;

// VIGNETTE
// Applies a circular vignette effect on the canvas if vignette_on.
// The vignette has a vignette_radius and a vignette_color.
// If vignette_ignore_transparent, transparent pixels will not have the vignette applied.
// This is generally useful if you want to apply a vignette on something besides the entire screen.
// Radius -> 0 tends to do some crazy effects
group_uniforms Vignette;
uniform bool vignette_on = false;
uniform bool vignette_ignore_transparent = false;
uniform vec3 vignette_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float vignette_radius: hint_range(0.001, 20.0, 0.01) = 1.0;

// TRANSPARENCY
// Controls transparency of the texture.
// If auto_flicker_speed is not zero, oscillates between transparency and auto_flicker_bounds at auto_flicker_speed.
// To prevent the auto flicker from starting in the middle of the animation, set auto_flicker_start_time to the global time when enabling auto flicker.
group_uniforms Transparency;
uniform float transparency: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flicker_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flicker_bound: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flicker_start_time = 0.0;

// --- Fragment Shader --- //
void fragment() 
{
	COLOR = texture(TEXTURE, UV);
	
	// --- CALCULATE CONSTANTS ---
	// WARNING - Don't use the ones with _ directly. 
	// the size of this canvas in pixels (ex 10x10)
	int _SIZE_IN_PIXELS_X = int(floor(1.0 / TEXTURE_PIXEL_SIZE.x));
	int _SIZE_IN_PIXELS_Y = int(floor(1.0 / TEXTURE_PIXEL_SIZE.y));
	// the size of the screen in pixels (ex 320x180)
	int _SCREEN_SIZE_IN_PIXELS_X = int(floor(1.0 / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_SIZE_IN_PIXELS_Y = int(floor(1.0 / SCREEN_PIXEL_SIZE.y));
	
	// the specific x and y pixel coordinates within texture
	int _PIXEL_X = int(floor(UV.x / TEXTURE_PIXEL_SIZE.x));
	int _PIXEL_Y = int(floor(UV.y / TEXTURE_PIXEL_SIZE.y));
	// the specific x and y pixel coordinates within screen
	int _SCREEN_PIXEL_X = int(floor(SCREEN_UV.x / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_PIXEL_Y = int(floor(SCREEN_UV.y / SCREEN_PIXEL_SIZE.y));
	
	// WARNING - Use these instead. This accounts for if this is a normal or post processing shader.
	// Size of a pixel for this canvas (ie 1/320x1/180)
	float PIXEL_SIZE_X = POST_PROCESSING ? SCREEN_PIXEL_SIZE.x : TEXTURE_PIXEL_SIZE.x;
	float PIXEL_SIZE_Y = POST_PROCESSING ? SCREEN_PIXEL_SIZE.y : TEXTURE_PIXEL_SIZE.y;
	// Size of the canvas in pixels. (ex 320x180)
	int SIZE_IN_PIXELS_X = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_X : _SIZE_IN_PIXELS_X;
	int SIZE_IN_PIXELS_Y = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_Y : _SIZE_IN_PIXELS_Y;
	// The specific XY coordinates of the current pixel.
	int X = POST_PROCESSING ? _SCREEN_PIXEL_X : _PIXEL_X;
	int Y = POST_PROCESSING ? _SCREEN_PIXEL_Y : _PIXEL_Y;
	// UV coordinates of the current pixel.
	vec2 MUV = POST_PROCESSING ? SCREEN_UV : UV;
	// ---
	
	
	// DISPLACE & PAN
	vec2 adjUV = vec2(0, 0); // WARNING - Use this instead of UV below, otherwise effects break with panning & displace
	
	float displaceUVX = MUV.x + (SCREEN_PIXEL_SIZE.x * float(displace_x));
	float displaceUVY = MUV.y + (SCREEN_PIXEL_SIZE.y * float(displace_y));
	if (displace_repeat) {
		adjUV = mod(vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed, 1.00000);
	} else {
		adjUV = vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed;
	}
	
	// $HACK$ doing this as a ternary breaks the preview, for some reason
	if (POST_PROCESSING) 
		COLOR = texture(SCREEN_TEXTURE, adjUV);
	else 
		COLOR = texture(TEXTURE, adjUV);
	
	// EXCLUDE COLORS
	bool is_exclude_color = use_exclude_colors && (vec3eq(COLOR.rgb, exclude_color1) || vec3eq(COLOR.rgb, exclude_color2) || vec3eq(COLOR.rgb, exclude_color3) || vec3eq(COLOR.rgb, exclude_color4));
	
	// RECOLOR
	if (vec3eq(COLOR.rgb, replace_color1)) 
		COLOR.rgb = replace_with_color1;
	if (vec3eq(COLOR.rgb, replace_color2)) 
		COLOR.rgb = replace_with_color2;
	if (vec3eq(COLOR.rgb, replace_color3)) 
		COLOR.rgb = replace_with_color3;
	if (vec3eq(COLOR.rgb, replace_color4)) 
		COLOR.rgb = replace_with_color4;
	if (vec3eq(COLOR.rgb, replace_color5)) 
		COLOR.rgb = replace_with_color5;
	if (vec3eq(COLOR.rgb, replace_color_outline))
		COLOR.rgb = replace_with_color_outline;
	
	// TINT, COLOR CORRECTION, and SCANLINE ignore excluded colors
	if (!is_exclude_color) {
		// TINT
		COLOR.rgb = mix(COLOR.rgb, tint_color, tint_strength);

		// FLASH
		// apply automatic flash
		if (auto_flash_speed != 0.0) {
			float auto_strength = mix(auto_flash_bound1, auto_flash_bound2, abs(vary0to1((TIME-auto_flash_start_time + TIME_OFFSET) * auto_flash_speed)));
			COLOR.rgb = mix(COLOR.rgb, auto_flash_color, auto_strength);
		}
		// apply manual flash
		COLOR.rgb = mix(COLOR.rgb, flash_color, flash_strength);

		// COLOR CORRECTION
		COLOR.r = mix(COLOR.r, 1.0, red_correct);
		COLOR.g = mix(COLOR.g, 1.0, green_correct);
		COLOR.b = mix(COLOR.b, 1.0, blue_correct);
		COLOR.rgb = mix(COLOR.rgb, vec3(0.2126 * COLOR.r + 0.7152 * COLOR.g + 0.0722 * COLOR.b), gray_correct);
		COLOR.rgb = mix(vec3(0.0), COLOR.rgb, brightness_correct);
		COLOR.rgb = mix(vec3(0.5), COLOR.rgb, contrast_correct);
		COLOR.rgb = mix(vec3(dot(vec3(1.0), COLOR.rbg)), COLOR.rgb, saturation_correct);

		// SCANLINE
		// FIX
		if (COLOR.a != 0.0) {
			float l_to_r_pos = !auto_scanline_left_to_right_on ? scanline_left_to_right_position : abs((auto_scanline_left_to_right_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_left_to_right_start_time + TIME_OFFSET, auto_scanline_left_to_right_delay + auto_scanline_left_to_right_scan_duration), 0.0, auto_scanline_left_to_right_scan_duration)/auto_scanline_left_to_right_scan_duration)));
			float t_to_b_pos = !auto_scanline_top_to_bottom_on ? scanline_top_to_bottom_position : abs((auto_scanline_top_to_bottom_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_top_to_bottom_start_time + TIME_OFFSET, auto_scanline_top_to_bottom_delay + auto_scanline_top_to_bottom_scan_duration), 0.0, auto_scanline_top_to_bottom_scan_duration)/auto_scanline_top_to_bottom_scan_duration)));
			float tl_to_br_pos = !auto_scanline_topleft_to_bottomright_on ? scanline_topleft_to_bottomright_position : abs((auto_scanline_topleft_to_bottomright_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topleft_to_bottomright_start_time + TIME_OFFSET, auto_scanline_topleft_to_bottomright_delay + auto_scanline_topleft_to_bottomright_scan_duration), 0.0, auto_scanline_topleft_to_bottomright_scan_duration)/auto_scanline_topleft_to_bottomright_scan_duration)));
			float tr_to_bl_pos = !auto_scanline_topright_to_bottomleft_on ? scanline_topright_to_bottomleft_position : abs((auto_scanline_topright_to_bottomleft_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topright_to_bottomleft_start_time + TIME_OFFSET, auto_scanline_topright_to_bottomleft_delay + auto_scanline_topright_to_bottomleft_scan_duration), 0.0, auto_scanline_topright_to_bottomleft_scan_duration)/auto_scanline_topright_to_bottomleft_scan_duration)));

			if (X == int(floor(l_to_r_pos / float(PIXEL_SIZE_X))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (Y == int(floor(t_to_b_pos / float(PIXEL_SIZE_Y))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			int scanline_target_tlbr = int(floor(tl_to_br_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y)));
			int scanline_target_trbl = int(floor(tr_to_bl_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y))) - SIZE_IN_PIXELS_Y;
			if (X+Y == scanline_target_tlbr)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (X-Y == scanline_target_trbl)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
		}
	}

	// GLOW
	if (glow_thickness != 0) {
		vec2 outline_size = TEXTURE_PIXEL_SIZE * float(glow_thickness);
		float outline = 0.0;
		for (int i = 0; i < HORIZONTAL_VERTICAL_OFFSETS.length(); i++) {
			outline += texture(TEXTURE, adjUV + outline_size * HORIZONTAL_VERTICAL_OFFSETS[i]).a;
		}
		if (glow_diagonals) {
			for (int i = 0; i < DIAGONAL_OUTLINE_OFFSETS.length(); i++) {
				outline += texture(TEXTURE, adjUV + outline_size * DIAGONAL_OUTLINE_OFFSETS[i]).a;
			}
		}
		outline = min(outline, 1.0);
		// this is a bit of a coding $HACK$ to make auto_glow_bound do nothing if auto_glow_speed is 0, but it definitely works
		float alp = auto_glow_speed == 0.0 ? 1.0 : mix(auto_glow_bound, glow_color.a, vary0to1((TIME - auto_glow_start_time + TIME_OFFSET) * auto_glow_speed));
		COLOR = mix(COLOR, glow_color * alp, outline - COLOR.a);
	}

	// DISINTEGRATE
	if (!is_exclude_color && COLOR.a != 0.0) {
		vec2 s = adjUV * vec2(float(disintegrate_seed));
		s *= auto_disintegrate_random_seed_speed != 0.0 ? float(int(TIME / mix(1.0, 0.001, auto_disintegrate_random_seed_speed))) : 1.0;
		float r = random(s);
		if (r < disintegrate_strength) {
			float r_alpha = randf_range(s, disintegrate_alpha_bound1, disintegrate_alpha_bound2);
			COLOR.rgb = mix(COLOR.rgb, disintegrate_color, r_alpha);
			if (!disintegrate_as_static)
				COLOR.a = r_alpha;
		}
	}

	// FOG
	if (fog_enabled) {
		vec2 fog_uv = MUV + fog_speed * TIME;
		float noise_alpha = texture(fog_noise_texture, fog_uv).r;
		// Convert noise from (0.0, 1.0) to (-1.0, 1.0)
		float fog = clamp((noise_alpha * 2.0 - 1.0) + (fog_density * 2.0), 0.0, 1.0);
		COLOR.a *= fog * fog_opacity;
	}

	// COLORLINES	
	if (!is_exclude_color) {
		if (X % vertical_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, vertical_colorline_color, vertical_colorline_strength);
		}
		if (Y % horizontal_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, horizontal_colorline_color, horizontal_colorline_strength);
		}
	}

	// CHECKER
	if (!is_exclude_color) {	
		if (X/checker_x_size % checker_x_pattern != Y/checker_y_size % checker_y_pattern) {
			float pixel_darkness = (3.0 - (COLOR.r + COLOR.g + COLOR.b)) * checker_contrast_ratio; // calculates 0.0 to 1.0 where 1.0 is pure black and 0.0 is pure white
			vec3 cbcolor = mix(checker_color.rgb, vec3(0.0), pixel_darkness * checker_contrast_amount);
			COLOR.rgb = mix(COLOR.rgb, cbcolor, checker_strength);
		}
	}

	// MOUSELIGHT
	if (mouselight_on && (!mouselight_checker || X % 2 == Y % 2)) {
		float mouse_with_flicker = mix(auto_mouselight_flicker_bound, float(mouselight_size), vary0to1(TIME * auto_mouselight_flicker_speed));
		float dist_from_mouse = sqrt(pow(float(_SCREEN_PIXEL_X - int(MOUSE.x)), 2.0) + pow(float(_SCREEN_PIXEL_Y - int(MOUSE.y)), 2.0));
		if (dist_from_mouse <= float(mouse_with_flicker)) {
			//todo - make softening with distance optional as uniform
			float distance_mod = clamp((mouse_with_flicker - dist_from_mouse) / mouse_with_flicker, 0.0, 1.0);
			COLOR.rgb = mix(COLOR.rgb, mouselight_color, distance_mod * mouselight_strength);
		}
	}

	// CUT
	if (MUV.x < cut_left)
		COLOR.a = 0.0;
	if (MUV.x > 1.0-cut_right)
		COLOR.a = 0.0;
	if (MUV.y < cut_top)
		COLOR.a = 0.0;
	if (MUV.y > 1.0-cut_bottom)
		COLOR.a = 0.0;

	// VIGNETTE
	if (vignette_on && ((!vignette_ignore_transparent || COLOR.a != 0.0)) && !is_exclude_color) {
		float x = abs(adjUV.x-.5)*2.0;
		float y = abs(adjUV.y-.5)*2.0;
		float v = (sqrt((x*x)+(y*y))/vignette_radius);
		COLOR = mix(COLOR, vec4(vignette_color.r, vignette_color.g, vignette_color.b, 1.0), v);
	}

	// TRANSPARENCY
	if (COLOR.a != 0.0) {
		COLOR.a = mix(COLOR.a * transparency, auto_flicker_bound, vary0to1((TIME-auto_flicker_start_time + TIME_OFFSET) * auto_flicker_speed));
	}
}

void vertex()
{
	
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_vtiq0"]
shader = SubResource("Shader_sl100")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(0.784314, 0.180392, 0.952941, 1)
shader_parameter/auto_flash_speed = 5.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 0.2
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_eloju"]
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(0.909804, 0.2, 0.243137, 1)
shader_parameter/flash_strength = 1.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 0.75
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(-0.02, 0)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 8.0
shader_parameter/auto_mouselight_flicker_bound = 10.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_6w1vx"]
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0.121569, 0.827451, 0.768627, 1)
shader_parameter/tint_strength = 1.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 0.75
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(-0.02, 0)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 8.0
shader_parameter/auto_mouselight_flicker_bound = 10.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_exojv"]
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.854902, 0.878431, 0.917647, 1)
shader_parameter/exclude_color3 = Color(0.701961, 0.72549, 0.819608, 1)
shader_parameter/exclude_color4 = Color(0.545098, 0.576471, 0.686275, 1)
shader_parameter/exclude_color5 = Color(0.976471, 0.639216, 0.105882, 1)
shader_parameter/exclude_color6 = Color(0.980392, 0.415686, 0.0392157, 1)
shader_parameter/exclude_color7 = Color(0.87451, 0.243137, 0.137255, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(1, 1, 1, 1)
shader_parameter/replace_with_color1 = Color(0.729412, 0.101961, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(0.956863, 0.552941, 0, 1)
shader_parameter/auto_flash_speed = 5.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 0.75
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(-0.02, 0)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 8.0
shader_parameter/auto_mouselight_flicker_bound = 10.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_hx7il"]
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.854902, 0.878431, 0.917647, 1)
shader_parameter/exclude_color3 = Color(0.701961, 0.72549, 0.819608, 1)
shader_parameter/exclude_color4 = Color(0.545098, 0.576471, 0.686275, 1)
shader_parameter/exclude_color5 = Color(0.976471, 0.639216, 0.105882, 1)
shader_parameter/exclude_color6 = Color(0.980392, 0.415686, 0.0392157, 1)
shader_parameter/exclude_color7 = Color(0.87451, 0.243137, 0.137255, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(1, 1, 1, 1)
shader_parameter/replace_with_color1 = Color(0.729412, 0.101961, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(0.956863, 0.552941, 0, 1)
shader_parameter/auto_flash_speed = 5.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 0.75
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(-0.02, 0)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 8.0
shader_parameter/auto_mouselight_flicker_bound = 10.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="Shader" id="Shader_ty7jo"]
code = "// Ben's Uber Pixel Shader
// WARNING - Shader expects uniform inputs in the range 0.0 - 1.0 for Colors. 
//           Therefore, be sure that Colors being passed in are in the correct range of (0-1, 0-1, 0-1, 0-1).
shader_type canvas_item;

// --- Utilty Functions --- //
const bool DEBUG = true;
const float TIME_OFFSET = 10.0; //offset all start times by this... for some reason things line up better with expectations
const vec2 HORIZONTAL_VERTICAL_OFFSETS[4] = {vec2(0, 1), vec2(-1, 0), vec2(1, 0), vec2(0, -1)};
const vec2 DIAGONAL_OUTLINE_OFFSETS[4] = {vec2(1, 1), vec2(-1, 1), vec2(1, -1), vec2(-1, -1)};

// checks if two values are 'equal' (within EPSILON of each other)
// necessary when doing float calculations since it's not perfectly precise
const float EPSILON = 0.001;
bool floateq(float val1, float val2) { return val1 >= val2 - EPSILON && val1 <= val2 + EPSILON; }
bool vec3eq(vec3 val1, vec3 val2) { return floateq(val1.r, val2.r) && floateq(val1.g, val2.g) && floateq(val1.b, val2.b); }

// Author: Michael Pohoreski https://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader
float random(vec2 seed){ return fract(cos(dot(seed, vec2(23.14069263277926, 2.665144142690225))) * 12345.6789); }
float snoise3(vec2 seed) { return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453); }
float randf_range(vec2 seed, float b1, float b2) { return mix(b1, b2, random(seed)); }
int randi_range(vec2 seed, int b1, int b2) { return int(randf_range(seed, float(b1), float(b2))); }
float sin0to1(float time) { return (sin(time)+1.0)/2.0; }
float cos0to1(float time) { return (cos(time)+1.0)/2.0; } 
float vary0to1(float time) { return 1.0-(cos(time)+1.0)/2.0; } // a transformed cos function that varies from 0 to 1. f(0) = 0, f(pi) = 1, f(2pi) = 0. 

uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;

uniform bool POST_PROCESSING = false;

// pass in the mouse position here
uniform vec2 MOUSE = vec2(20, 20);


// --- Effects --- //
// EXCLUDE
// If use_exclude_colors, pixels of these colors are excluded from tint, color correction, scanline, and vignette effects.
group_uniforms Exclude;
uniform bool use_exclude_colors = true;
uniform vec3 exclude_color1: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color2: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color3: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color4: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders

// PAN/DISPLACE
// Displaces all pixels by (displace_x, displace_y). Texture repeats if displace_repeat.
// WARNING - Offsetting beyond the bounds of the texture will result in the texture being cut off
group_uniforms PanAndDisplacement;
uniform int displace_x = 0;
uniform int displace_y = 0;
uniform bool displace_repeat = true;
// Texture will automatically scroll if auto_pan_speed is nonzero.
// Set auto_pan_speed to a positive number for left/up panning; negative number for right/down panning
// WARNING - Repeat generally should be true for auto_pan_speed, otherwise it will immediately pan out of view
uniform vec2 auto_pan_speed = vec2(0, 0);

// RECOLOR
// Replaces replace_colorN with replace_with_colorN.
group_uniforms Recolor;
uniform vec3 replace_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color5: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color5: source_color = vec3(0.0, 0.0, 0.0);

// special extra uniform specifically intended to recolor outlines
uniform vec3 replace_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 replace_with_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392);

// TINT
// Tint the texture with tint_color.
// The strength of the tint is controlled by tint_strength.
group_uniforms Tint;
uniform vec3 tint_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float tint_strength: hint_range(0.0, 1.0) = 0.0;

// FLASH
// Flash the texture with flash_color. Essentially, this is a second layer of tint.
// flash_strength controls how much color is the original and how much is the flash_color.
group_uniforms Flash;
uniform vec3 flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float flash_strength: hint_range(0.0, 1.0) = 0.0;
// auto_flash_speed will cause infinite and repeated flashing in auto_flash_color if nonzero and controls the speed of this flashing.
// auto_flash_bound1 and auto_flash_bound2 provide the bounds of the flashing effect.
// To prevent the auto flash from starting in the middle of the animation, set auto_flash_start_time to the global time when enabling auto flash.
// TIP - auto flash and regular ('manual') flash stack, which is why they have two separate colors.
uniform vec3 auto_flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float auto_flash_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flash_bound1: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flash_bound2: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flash_start_time = 0.0;

// COLOR CORRECTION
group_uniforms ColorCorrection;
// Applies red, green, or blue color correction with red_correct, green_correct, and blue_correct. 
// Applies grayscale with gray_correct.
// Modify brightness, contrast, or saturation with brightness_correct, contrast_correct, and saturation_correct.
// TIP - these values can actually go higher or lower, if you want a more extreme effect
uniform float red_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float green_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float blue_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float gray_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float brightness_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float contrast_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float saturation_correct: hint_range(0.0, 2.0, 0.01) = 1.0;

// TODO - more funky color options
// rg swap - swaps the original (before any other swaps) value of r and g
// gb swap
// br swap
// r_eq_g - sets r = g
// r_eq_b
// g_eq_r
// g_eq_b
// b_eq_r
// b_eq_g

// TODO - ROUGHEN - applies randomized brightness modifications across the texture (both positive and negative) to 'roughen' it up

// SCANLINES
// Create a line across the canvas of scanline_color. scanline_strength controls the alpha of the line.
// Define the position of the line with scanline_left_to_right_position, scanline_top_to_bottom_position,
// scanline_topleft_to_bottomright_position, and scanline_topright_to_bottomleft_position.
// The line is vertical if going left to right, horizontal if going top to bottom, and diagonal for the other two.
group_uniforms Scanline;
uniform vec3 scanline_color: source_color = vec3(0.98, 0.69, 0.23);
uniform float scanline_strength: hint_range(0.0, 1.0, 0.01) = 1.0;
uniform float scanline_left_to_right_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_top_to_bottom_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topleft_to_bottomright_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topright_to_bottomleft_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
// auto_scanline_DIRECTION_on will enable automatic repeating scanlines in that direction.
// auto_scanline_DIRECTION_reverse will flip the direction.
// The scan will be visible for auto_scanline_DIRECTION_scan_duration, with a delay of 
// auto_scanline_DIRECTION_scan_duration before the next scan begins.
// To prevent the scanline from starting in the middle of the texture, provide the global time to auto_scanline_DIRECTION_start_time.
uniform bool auto_scanline_left_to_right_on = false;
uniform bool auto_scanline_left_to_right_reverse = false;
uniform float auto_scanline_left_to_right_start_time = 0.0;
uniform float auto_scanline_left_to_right_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_left_to_right_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_top_to_bottom_on = false;
uniform bool auto_scanline_top_to_bottom_reverse = false;
uniform float auto_scanline_top_to_bottom_start_time = 0.0;
uniform float auto_scanline_top_to_bottom_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_top_to_bottom_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topleft_to_bottomright_on = false;
uniform bool auto_scanline_topleft_to_bottomright_reverse = false;
uniform float auto_scanline_topleft_to_bottomright_start_time = 0.0;
uniform float auto_scanline_topleft_to_bottomright_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topleft_to_bottomright_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topright_to_bottomleft_on = false;
uniform bool auto_scanline_topright_to_bottomleft_reverse = false;
uniform float auto_scanline_topright_to_bottomleft_start_time = 0.0;
uniform float auto_scanline_topright_to_bottomleft_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topright_to_bottomleft_delay: hint_range(0.0, 10.0, 0.01) = 1.0;

// OUTLINE
// Adds a pixel outline to the texture, with glow_color and glow_thickness.
// glow_dialgonals controls if we also create this outline diagonally, which makes it thicker.
// This can be used to create a solid outline if auto_glow_speed is left at 0.
// WARNING - Shaders cannot draw outside of the bounds of the canvas, so the canvas may need extra transparent space on the sides.
// WARNING - Can have some odd effects with sprites containing partial transparency.
group_uniforms GlowAndOutline;
uniform vec4 glow_color: source_color = vec4(1.0);
uniform int glow_thickness: hint_range(0, 10) = 0;
uniform bool glow_diagonals = false;
// auto_glow_speed defines the speed of a glow fluctuating alpha between the outline's alpha and auto_glow_bound at auto_glow_speed.
// To prevent the auto glow from starting in the middle of the animation, set auto_glow_start_time to the global time when enabling auto glow.
uniform float auto_glow_speed: hint_range(0.0, 30.0) = 0.0;
uniform float auto_glow_bound: hint_range(0.0, 1.0) = 0.75;
uniform float auto_glow_start_time = 0.0;

// DISINTEGRATE
// Sets 'random' pixels in the canvas to disintegrate_color with alpha between disintegrate_alpha_bound1 and disintegrate_alpha_bound2.
// By default, since these bounds are 0, the pixels will be made fully transparent and therefore disintegrate_color is unused.
// disintegrate_strength controls the amount of pixels affected, from none (0) to all of them (1).
// Change the pattern via disintegrate_seed.
// disintegrate_as_static changes the purpose of disintegrate to not affect the alpha of the texture.
// Instead, it layers a static-looking pattern on top using disintegrate_color, where the color is based on disintegrate_color
// and the alpha of the static pattern ranges randomly between disintegrate_alpha_bound1 and disintegrate_alpha_bound2 per pixel.
// Note that with the default bounds of 0 and 0, this setting creates no effect whatsoever.
// If auto_disintegrate_random_seed_speed is nonzero, applies randomization to the seed over time based on speed.
// In this case, disintegrate_seed has no effect.
group_uniforms Disintegrate;
uniform int disintegrate_seed = 1;
uniform vec3 disintegrate_color : source_color = vec3(0.0, 0.0, 0.0);
uniform float disintegrate_strength: hint_range(0.0, 1.0) = 0.0;
uniform float disintegrate_alpha_bound1 = 0.0;
uniform float disintegrate_alpha_bound2 = 0.0;
uniform bool disintegrate_as_static = false;
uniform float auto_disintegrate_random_seed_speed: hint_range(0.0, 1.0) = 0.0;

// FOG
// Applies a fog_noise_texture filter over the texture with modifiable fog_opacity and fog_density, moving at fog_speed
// Mostly used to create fog effects by assigning to a ColorRect (color is changable by changing ColorRect color too!)
// NOTE - Don't use this as a post processing shader. 
group_uniforms Fog;
uniform bool fog_enabled = false;
uniform sampler2D fog_noise_texture: repeat_enable, filter_nearest;
uniform float fog_opacity: hint_range(0.0, 1.0) = 0.5;
uniform float fog_density: hint_range(0.0, 1.0) = 0.25;
uniform vec2 fog_speed = vec2(-0.02, 0.0);

// COLORLINES
// Creates vertical/horizontal lines of colorline_color spaced colorline_spacing pixels apart 
// with colorline_strength alpha across the texture.
group_uniforms Colorlines;
uniform vec3 vertical_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int vertical_colorline_spacing = 2;
uniform float vertical_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;
uniform vec3 horizontal_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int horizontal_colorline_spacing = 2;
uniform float horizontal_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;

// CHECKER
// Creates a checkerboard pattern across the texture of checker_color with checker_strength alpha.
// checker_x_size and checker_y_size defines the size of each rectangular checker
// checker_x_pattern and checker_y_pattern affect the pattern of the checker pattern (which
// can stop looking checkered with different values).
// checker_contrast_amount applies a darkening effect to pixels of the checkerboard that are already dark.
// checker_contrast_ratio increases the contrast of the darkening effect between light and dark colored pixels,
// ie dark pixels become even darker.
group_uniforms CHECKER;
uniform vec3 checker_color: source_color = vec3(0.2, 0.2, 0.2);
uniform float checker_strength: hint_range(0.0, 1.0, 0.01) = 0.0; //0.3 is a good one
uniform int checker_x_size: hint_range(1, 64, 1) = 1;
uniform int checker_y_size: hint_range(1, 64, 1) = 1;
uniform int checker_x_pattern: hint_range(1, 32, 1) = 2;
uniform int checker_y_pattern: hint_range(1, 32, 1) = 2;
uniform float checker_contrast_amount: hint_range(-10.0, 10.0, 0.1) = 1.0;
uniform float checker_contrast_ratio: hint_range(0.0, 10.0, 0.01) = 0.5;
// TODO - experiment a bit more with the contrast calculation here - maybe subtract 0.5 and LIGHTEN lighter areas?

// MOUSELIGHT
// Creates a circular lighting effect at the mouse's position if mouselight_on, of mouselight_color and mouselight_strength alpha.
// Mouselight size defines the radius of the light effect.
// If mouselight_soften_edges, pixels further from the center of the light are more transparent.
// If mouselight_checker, the effect will be checkered in a way that interacts with the CHECKER effect.
// If auto_mouselight_flicker_speed is non-zero, the light will oscillate in size between mouselight_size and auto_mouselight_flicker_speed
group_uniforms Mouselight;
uniform bool mouselight_on = false;
uniform vec3 mouselight_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float mouselight_strength = 0.5;
uniform int mouselight_size = 8;
uniform bool mouselight_soften_edges = true;
uniform bool mouselight_checker = false;
uniform float auto_mouselight_flicker_speed: hint_range(0.0, 20.0) = 8;
uniform float auto_mouselight_flicker_bound = 10;

// CUT
// Cuts off all pixels of the texture from left/right/top/bottom.
group_uniforms Cut;
uniform float cut_left: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_right: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_top: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_bottom: hint_range(0.0, 1.0, 0.001) = 0.0;

// VIGNETTE
// Applies a circular vignette effect on the canvas if vignette_on.
// The vignette has a vignette_radius and a vignette_color.
// If vignette_ignore_transparent, transparent pixels will not have the vignette applied.
// This is generally useful if you want to apply a vignette on something besides the entire screen.
// Radius -> 0 tends to do some crazy effects
group_uniforms Vignette;
uniform bool vignette_on = false;
uniform bool vignette_ignore_transparent = false;
uniform vec3 vignette_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float vignette_radius: hint_range(0.001, 20.0, 0.01) = 1.0;

// TRANSPARENCY
// Controls transparency of the texture.
// If auto_flicker_speed is not zero, oscillates between transparency and auto_flicker_bounds at auto_flicker_speed.
// To prevent the auto flicker from starting in the middle of the animation, set auto_flicker_start_time to the global time when enabling auto flicker.
group_uniforms Transparency;
uniform float transparency: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flicker_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flicker_bound: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flicker_start_time = 0.0;

// --- Fragment Shader --- //
void fragment() 
{
	COLOR = texture(TEXTURE, UV);
	
	// --- CALCULATE CONSTANTS ---
	// WARNING - Don't use the ones with _ directly. 
	// the size of this canvas in pixels (ex 10x10)
	int _SIZE_IN_PIXELS_X = int(floor(1.0 / TEXTURE_PIXEL_SIZE.x));
	int _SIZE_IN_PIXELS_Y = int(floor(1.0 / TEXTURE_PIXEL_SIZE.y));
	// the size of the screen in pixels (ex 320x180)
	int _SCREEN_SIZE_IN_PIXELS_X = int(floor(1.0 / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_SIZE_IN_PIXELS_Y = int(floor(1.0 / SCREEN_PIXEL_SIZE.y));
	
	// the specific x and y pixel coordinates within texture
	int _PIXEL_X = int(floor(UV.x / TEXTURE_PIXEL_SIZE.x));
	int _PIXEL_Y = int(floor(UV.y / TEXTURE_PIXEL_SIZE.y));
	// the specific x and y pixel coordinates within screen
	int _SCREEN_PIXEL_X = int(floor(SCREEN_UV.x / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_PIXEL_Y = int(floor(SCREEN_UV.y / SCREEN_PIXEL_SIZE.y));
	
	// WARNING - Use these instead. This accounts for if this is a normal or post processing shader.
	// Size of a pixel for this canvas (ie 1/320x1/180)
	float PIXEL_SIZE_X = POST_PROCESSING ? SCREEN_PIXEL_SIZE.x : TEXTURE_PIXEL_SIZE.x;
	float PIXEL_SIZE_Y = POST_PROCESSING ? SCREEN_PIXEL_SIZE.y : TEXTURE_PIXEL_SIZE.y;
	// Size of the canvas in pixels. (ex 320x180)
	int SIZE_IN_PIXELS_X = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_X : _SIZE_IN_PIXELS_X;
	int SIZE_IN_PIXELS_Y = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_Y : _SIZE_IN_PIXELS_Y;
	// The specific XY coordinates of the current pixel.
	int X = POST_PROCESSING ? _SCREEN_PIXEL_X : _PIXEL_X;
	int Y = POST_PROCESSING ? _SCREEN_PIXEL_Y : _PIXEL_Y;
	// UV coordinates of the current pixel.
	vec2 MUV = POST_PROCESSING ? SCREEN_UV : UV;
	// ---
	
	
	// DISPLACE & PAN
	vec2 adjUV = vec2(0, 0); // WARNING - Use this instead of UV below, otherwise effects break with panning & displace
	
	float displaceUVX = MUV.x + (SCREEN_PIXEL_SIZE.x * float(displace_x));
	float displaceUVY = MUV.y + (SCREEN_PIXEL_SIZE.y * float(displace_y));
	if (displace_repeat) {
		adjUV = mod(vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed, 1.00000);
	} else {
		adjUV = vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed;
	}
	
	// $HACK$ doing this as a ternary breaks the preview, for some reason
	if (POST_PROCESSING) 
		COLOR = texture(SCREEN_TEXTURE, adjUV);
	else 
		COLOR = texture(TEXTURE, adjUV);
	
	// EXCLUDE COLORS
	bool is_exclude_color = use_exclude_colors && (vec3eq(COLOR.rgb, exclude_color1) || vec3eq(COLOR.rgb, exclude_color2) || vec3eq(COLOR.rgb, exclude_color3) || vec3eq(COLOR.rgb, exclude_color4));
	
	// RECOLOR
	if (vec3eq(COLOR.rgb, replace_color1)) 
		COLOR.rgb = replace_with_color1;
	if (vec3eq(COLOR.rgb, replace_color2)) 
		COLOR.rgb = replace_with_color2;
	if (vec3eq(COLOR.rgb, replace_color3)) 
		COLOR.rgb = replace_with_color3;
	if (vec3eq(COLOR.rgb, replace_color4)) 
		COLOR.rgb = replace_with_color4;
	if (vec3eq(COLOR.rgb, replace_color5)) 
		COLOR.rgb = replace_with_color5;
	if (vec3eq(COLOR.rgb, replace_color_outline))
		COLOR.rgb = replace_with_color_outline;
	
	// TINT, COLOR CORRECTION, and SCANLINE ignore excluded colors
	if (!is_exclude_color) {
		// TINT
		COLOR.rgb = mix(COLOR.rgb, tint_color, tint_strength);

		// FLASH
		// apply automatic flash
		if (auto_flash_speed != 0.0) {
			float auto_strength = mix(auto_flash_bound1, auto_flash_bound2, abs(vary0to1((TIME-auto_flash_start_time + TIME_OFFSET) * auto_flash_speed)));
			COLOR.rgb = mix(COLOR.rgb, auto_flash_color, auto_strength);
		}
		// apply manual flash
		COLOR.rgb = mix(COLOR.rgb, flash_color, flash_strength);

		// COLOR CORRECTION
		COLOR.r = mix(COLOR.r, 1.0, red_correct);
		COLOR.g = mix(COLOR.g, 1.0, green_correct);
		COLOR.b = mix(COLOR.b, 1.0, blue_correct);
		COLOR.rgb = mix(COLOR.rgb, vec3(0.2126 * COLOR.r + 0.7152 * COLOR.g + 0.0722 * COLOR.b), gray_correct);
		COLOR.rgb = mix(vec3(0.0), COLOR.rgb, brightness_correct);
		COLOR.rgb = mix(vec3(0.5), COLOR.rgb, contrast_correct);
		COLOR.rgb = mix(vec3(dot(vec3(1.0), COLOR.rbg)), COLOR.rgb, saturation_correct);

		// SCANLINE
		// FIX
		if (COLOR.a != 0.0) {
			float l_to_r_pos = !auto_scanline_left_to_right_on ? scanline_left_to_right_position : abs((auto_scanline_left_to_right_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_left_to_right_start_time + TIME_OFFSET, auto_scanline_left_to_right_delay + auto_scanline_left_to_right_scan_duration), 0.0, auto_scanline_left_to_right_scan_duration)/auto_scanline_left_to_right_scan_duration)));
			float t_to_b_pos = !auto_scanline_top_to_bottom_on ? scanline_top_to_bottom_position : abs((auto_scanline_top_to_bottom_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_top_to_bottom_start_time + TIME_OFFSET, auto_scanline_top_to_bottom_delay + auto_scanline_top_to_bottom_scan_duration), 0.0, auto_scanline_top_to_bottom_scan_duration)/auto_scanline_top_to_bottom_scan_duration)));
			float tl_to_br_pos = !auto_scanline_topleft_to_bottomright_on ? scanline_topleft_to_bottomright_position : abs((auto_scanline_topleft_to_bottomright_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topleft_to_bottomright_start_time + TIME_OFFSET, auto_scanline_topleft_to_bottomright_delay + auto_scanline_topleft_to_bottomright_scan_duration), 0.0, auto_scanline_topleft_to_bottomright_scan_duration)/auto_scanline_topleft_to_bottomright_scan_duration)));
			float tr_to_bl_pos = !auto_scanline_topright_to_bottomleft_on ? scanline_topright_to_bottomleft_position : abs((auto_scanline_topright_to_bottomleft_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topright_to_bottomleft_start_time + TIME_OFFSET, auto_scanline_topright_to_bottomleft_delay + auto_scanline_topright_to_bottomleft_scan_duration), 0.0, auto_scanline_topright_to_bottomleft_scan_duration)/auto_scanline_topright_to_bottomleft_scan_duration)));

			if (X == int(floor(l_to_r_pos / float(PIXEL_SIZE_X))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (Y == int(floor(t_to_b_pos / float(PIXEL_SIZE_Y))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			int scanline_target_tlbr = int(floor(tl_to_br_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y)));
			int scanline_target_trbl = int(floor(tr_to_bl_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y))) - SIZE_IN_PIXELS_Y;
			if (X+Y == scanline_target_tlbr)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (X-Y == scanline_target_trbl)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
		}
	}

	// GLOW
	if (glow_thickness != 0) {
		vec2 outline_size = TEXTURE_PIXEL_SIZE * float(glow_thickness);
		float outline = 0.0;
		for (int i = 0; i < HORIZONTAL_VERTICAL_OFFSETS.length(); i++) {
			outline += texture(TEXTURE, adjUV + outline_size * HORIZONTAL_VERTICAL_OFFSETS[i]).a;
		}
		if (glow_diagonals) {
			for (int i = 0; i < DIAGONAL_OUTLINE_OFFSETS.length(); i++) {
				outline += texture(TEXTURE, adjUV + outline_size * DIAGONAL_OUTLINE_OFFSETS[i]).a;
			}
		}
		outline = min(outline, 1.0);
		// this is a bit of a coding $HACK$ to make auto_glow_bound do nothing if auto_glow_speed is 0, but it definitely works
		float alp = auto_glow_speed == 0.0 ? 1.0 : mix(auto_glow_bound, glow_color.a, vary0to1((TIME - auto_glow_start_time + TIME_OFFSET) * auto_glow_speed));
		COLOR = mix(COLOR, glow_color * alp, outline - COLOR.a);
	}

	// DISINTEGRATE
	if (!is_exclude_color && COLOR.a != 0.0) {
		vec2 s = adjUV * vec2(float(disintegrate_seed));
		s *= auto_disintegrate_random_seed_speed != 0.0 ? float(int(TIME / mix(1.0, 0.001, auto_disintegrate_random_seed_speed))) : 1.0;
		float r = random(s);
		if (r < disintegrate_strength) {
			float r_alpha = randf_range(s, disintegrate_alpha_bound1, disintegrate_alpha_bound2);
			COLOR.rgb = mix(COLOR.rgb, disintegrate_color, r_alpha);
			if (!disintegrate_as_static)
				COLOR.a = r_alpha;
		}
	}

	// FOG
	if (fog_enabled) {
		vec2 fog_uv = MUV + fog_speed * TIME;
		float noise_alpha = texture(fog_noise_texture, fog_uv).r;
		// Convert noise from (0.0, 1.0) to (-1.0, 1.0)
		float fog = clamp((noise_alpha * 2.0 - 1.0) + (fog_density * 2.0), 0.0, 1.0);
		COLOR.a *= fog * fog_opacity;
	}

	// COLORLINES	
	if (!is_exclude_color) {
		if (X % vertical_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, vertical_colorline_color, vertical_colorline_strength);
		}
		if (Y % horizontal_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, horizontal_colorline_color, horizontal_colorline_strength);
		}
	}

	// CHECKER
	if (!is_exclude_color) {	
		if (X/checker_x_size % checker_x_pattern != Y/checker_y_size % checker_y_pattern) {
			float pixel_darkness = (3.0 - (COLOR.r + COLOR.g + COLOR.b)) * checker_contrast_ratio; // calculates 0.0 to 1.0 where 1.0 is pure black and 0.0 is pure white
			vec3 cbcolor = mix(checker_color.rgb, vec3(0.0), pixel_darkness * checker_contrast_amount);
			COLOR.rgb = mix(COLOR.rgb, cbcolor, checker_strength);
		}
	}

	// MOUSELIGHT
	if (mouselight_on && (!mouselight_checker || X % 2 == Y % 2)) {
		float mouse_with_flicker = mix(auto_mouselight_flicker_bound, float(mouselight_size), vary0to1(TIME * auto_mouselight_flicker_speed));
		float dist_from_mouse = sqrt(pow(float(_SCREEN_PIXEL_X - int(MOUSE.x)), 2.0) + pow(float(_SCREEN_PIXEL_Y - int(MOUSE.y)), 2.0));
		if (dist_from_mouse <= float(mouse_with_flicker)) {
			//todo - make softening with distance optional as uniform
			float distance_mod = clamp((mouse_with_flicker - dist_from_mouse) / mouse_with_flicker, 0.0, 1.0);
			COLOR.rgb = mix(COLOR.rgb, mouselight_color, distance_mod * mouselight_strength);
		}
	}

	// CUT
	if (MUV.x < cut_left)
		COLOR.a = 0.0;
	if (MUV.x > 1.0-cut_right)
		COLOR.a = 0.0;
	if (MUV.y < cut_top)
		COLOR.a = 0.0;
	if (MUV.y > 1.0-cut_bottom)
		COLOR.a = 0.0;

	// VIGNETTE
	if (vignette_on && ((!vignette_ignore_transparent || COLOR.a != 0.0)) && !is_exclude_color) {
		float x = abs(adjUV.x-.5)*2.0;
		float y = abs(adjUV.y-.5)*2.0;
		float v = (sqrt((x*x)+(y*y))/vignette_radius);
		COLOR = mix(COLOR, vec4(vignette_color.r, vignette_color.g, vignette_color.b, 1.0), v);
	}

	// TRANSPARENCY
	if (COLOR.a != 0.0) {
		COLOR.a = mix(COLOR.a * transparency, auto_flicker_bound, vary0to1((TIME-auto_flicker_start_time + TIME_OFFSET) * auto_flicker_speed));
	}
}

void vertex()
{
	
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_kheqr"]
shader = SubResource("Shader_ty7jo")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 0.75
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(-0.02, 0)
shader_parameter/vertical_colorline_color = Color(0.705882, 0.117647, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.05
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.1
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 8.0
shader_parameter/auto_mouselight_flicker_bound = 10.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = true
shader_parameter/vignette_ignore_transparent = true
shader_parameter/vignette_color = Color(0.294118, 0.298039, 0.670588, 1)
shader_parameter/vignette_radius = 9.311
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_7kp4x"]
resource_local_to_scene = true
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_gomxl"]
resource_local_to_scene = true
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_u7wvf"]
resource_local_to_scene = true
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_i88l0"]
resource_local_to_scene = true
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_04xvu"]
resource_local_to_scene = true
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_biei3"]
resource_local_to_scene = true
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_8gsjf"]
resource_local_to_scene = true
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_k7ltx"]
resource_local_to_scene = true
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(0.02, 0.01)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_uu5uq"]
resource_local_to_scene = true
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 0.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 0.75
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(-0.02, 0)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 8.0
shader_parameter/auto_mouselight_flicker_bound = 10.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="Curve" id="Curve_ue0n8"]
min_value = -1.0
_data = [Vector2(0, 1), 0.0, 0.0, 0, 0, Vector2(0.0752841, -1), 0.0, 0.0, 0, 0, Vector2(0.140625, 1), 0.0, 0.0, 0, 0, Vector2(0.272727, -1), 0.0, 0.0, 0, 0, Vector2(0.394886, 1), 0.0, 0.0, 0, 0, Vector2(0.53125, -1), 0.0, 0.0, 0, 0, Vector2(0.610795, 1), 0.0, 0.0, 0, 0, Vector2(0.742898, -1), 0.0, 0.0, 0, 0, Vector2(0.81392, 1), 0.0, 0.0, 0, 0, Vector2(0.920455, -1), 0.0, 0.0, 0, 0, Vector2(1, 1), 0.0, 0.0, 0, 0]
point_count = 11

[sub_resource type="CurveTexture" id="CurveTexture_wm5f8"]
curve = SubResource("Curve_ue0n8")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_t5ya3"]
emission_shape = 3
emission_box_extents = Vector3(1, 100, 1)
particle_flag_disable_z = true
spread = 10.0
gravity = Vector3(0, 0, 0)
initial_velocity_min = 110.0
initial_velocity_max = 150.0
orbit_velocity_min = 0.0
orbit_velocity_max = 0.0
hue_variation_min = -0.1
hue_variation_max = 0.1
hue_variation_curve = SubResource("CurveTexture_wm5f8")

[sub_resource type="Curve" id="Curve_i7mii"]
min_value = -1.0
_data = [Vector2(0, 1), 0.0, 0.0, 0, 0, Vector2(0.0752841, -1), 0.0, 0.0, 0, 0, Vector2(0.140625, 1), 0.0, 0.0, 0, 0, Vector2(0.272727, -1), 0.0, 0.0, 0, 0, Vector2(0.394886, 1), 0.0, 0.0, 0, 0, Vector2(0.53125, -1), 0.0, 0.0, 0, 0, Vector2(0.610795, 1), 0.0, 0.0, 0, 0, Vector2(0.742898, -1), 0.0, 0.0, 0, 0, Vector2(0.81392, 1), 0.0, 0.0, 0, 0, Vector2(0.920455, -1), 0.0, 0.0, 0, 0, Vector2(1, 1), 0.0, 0.0, 0, 0]
point_count = 11

[sub_resource type="CurveTexture" id="CurveTexture_m4xxc"]
curve = SubResource("Curve_i7mii")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_r1e2v"]
emission_shape = 3
emission_box_extents = Vector3(1, 100, 1)
particle_flag_disable_z = true
spread = 10.0
gravity = Vector3(0, 0, 0)
initial_velocity_min = 110.0
initial_velocity_max = 150.0
orbit_velocity_min = 0.0
orbit_velocity_max = 0.0
hue_variation_min = -0.1
hue_variation_max = 0.1
hue_variation_curve = SubResource("CurveTexture_m4xxc")

[sub_resource type="Gradient" id="Gradient_3t6cd"]
offsets = PackedFloat32Array(0, 0.78826, 1)
colors = PackedColorArray(0.737255, 0.290196, 0.607843, 1, 0.737255, 0.290196, 0.607843, 1, 0.737255, 0.290196, 0.607843, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_w2m7r"]
gradient = SubResource("Gradient_3t6cd")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_m5kuv"]
emission_shape = 1
emission_sphere_radius = 11.82
particle_flag_disable_z = true
direction = Vector3(0, 1, 0)
spread = 85.0
gravity = Vector3(0, 0, 0)
initial_velocity_min = 30.0
initial_velocity_max = 50.0
orbit_velocity_min = 0.0
orbit_velocity_max = 0.0
color_ramp = SubResource("GradientTexture1D_w2m7r")

[sub_resource type="Gradient" id="Gradient_s4bh3"]
offsets = PackedFloat32Array(0, 0.781971, 1)
colors = PackedColorArray(0.854902, 0.192157, 0.309804, 1, 0.854902, 0.192157, 0.309804, 1, 0.854902, 0.192157, 0.309804, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_0eeor"]
gradient = SubResource("Gradient_s4bh3")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_84yqa"]
emission_shape = 1
emission_sphere_radius = 11.82
particle_flag_disable_z = true
direction = Vector3(0, 1, 0)
spread = 90.0
gravity = Vector3(0, 0, 0)
initial_velocity_min = 30.0
initial_velocity_max = 50.0
orbit_velocity_min = 0.0
orbit_velocity_max = 0.0
color_ramp = SubResource("GradientTexture1D_0eeor")

[sub_resource type="Gradient" id="Gradient_6mqet"]
offsets = PackedFloat32Array(0, 0.995807)
colors = PackedColorArray(0.309804, 0.92549, 1, 1, 1, 1, 1, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_o567j"]
gradient = SubResource("Gradient_6mqet")

[sub_resource type="Curve" id="Curve_cwxbc"]
max_value = 5.0
_data = [Vector2(0, 0), 0.0, 0.0, 0, 0, Vector2(1, 5), 0.0, 0.0, 0, 0]
point_count = 2

[sub_resource type="CurveTexture" id="CurveTexture_12aw4"]
curve = SubResource("Curve_cwxbc")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_lkb7x"]
particle_flag_disable_z = true
direction = Vector3(0, 1, 0)
spread = 0.0
gravity = Vector3(0, 0, 0)
initial_velocity_min = 20.0
initial_velocity_max = 50.0
angular_velocity_max = 5.0
orbit_velocity_min = 10.0
orbit_velocity_max = 20.0
scale_curve = SubResource("CurveTexture_12aw4")
color_ramp = SubResource("GradientTexture1D_o567j")
hue_variation_max = 0.1
hue_variation_curve = SubResource("CurveTexture_m4xxc")

[sub_resource type="FastNoiseLite" id="FastNoiseLite_o6jch"]

[sub_resource type="NoiseTexture2D" id="NoiseTexture2D_ycsoo"]
seamless = true
seamless_blend_skirt = 0.7
noise = SubResource("FastNoiseLite_o6jch")

[sub_resource type="ShaderMaterial" id="ShaderMaterial_a7o28"]
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0.933333, 0.690196, 0.815686, 1)
shader_parameter/tint_strength = 1.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = true
shader_parameter/fog_opacity = 0.06
shader_parameter/fog_density = 0.0
shader_parameter/fog_speed = Vector2(0, -0.05)
shader_parameter/fog_noise_texture = SubResource("NoiseTexture2D_ycsoo")
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="FastNoiseLite" id="FastNoiseLite_uy8ym"]
seed = 5

[sub_resource type="NoiseTexture2D" id="NoiseTexture2D_64mkb"]
seamless = true
seamless_blend_skirt = 0.7
noise = SubResource("FastNoiseLite_uy8ym")

[sub_resource type="ShaderMaterial" id="ShaderMaterial_ruuci"]
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0.517647, 0.827451, 0.92549, 1)
shader_parameter/tint_strength = 0.3
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = true
shader_parameter/fog_opacity = 0.07
shader_parameter/fog_density = 0.09
shader_parameter/fog_speed = Vector2(0, -0.015)
shader_parameter/fog_noise_texture = SubResource("NoiseTexture2D_64mkb")
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_503b8"]
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0.247059, 0, 0.972549, 1)
shader_parameter/tint_strength = 1.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 1.0
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = true
shader_parameter/fog_opacity = 0.351
shader_parameter/fog_density = 0.23
shader_parameter/fog_speed = Vector2(0, -0.3)
shader_parameter/fog_noise_texture = SubResource("NoiseTexture2D_64mkb")
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 10.0
shader_parameter/auto_mouselight_flicker_bound = 3.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 1.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_6ippc"]
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0.960784, 0.129412, 0.0980392, 1)
shader_parameter/tint_strength = 1.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(0.87451, 0.258824, 0.0705882, 1)
shader_parameter/auto_flash_speed = 3.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 0.75
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(-0.02, 0)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 8.0
shader_parameter/auto_mouselight_flicker_bound = 10.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 0.1
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="Shader" id="Shader_fmgy3"]
code = "// Ben's Uber Pixel Shader
// WARNING - Shader expects uniform inputs in the range 0.0 - 1.0 for Colors. 
//           Therefore, be sure that Colors being passed in are in the correct range of (0-1, 0-1, 0-1, 0-1).
shader_type canvas_item;

// --- Utilty Functions --- //
const bool DEBUG = true;
const float TIME_OFFSET = 10.0; //offset all start times by this... for some reason things line up better with expectations
const vec2 HORIZONTAL_VERTICAL_OFFSETS[4] = {vec2(0, 1), vec2(-1, 0), vec2(1, 0), vec2(0, -1)};
const vec2 DIAGONAL_OUTLINE_OFFSETS[4] = {vec2(1, 1), vec2(-1, 1), vec2(1, -1), vec2(-1, -1)};

// checks if two values are 'equal' (within EPSILON of each other)
// necessary when doing float calculations since it's not perfectly precise
const float EPSILON = 0.001;
bool floateq(float val1, float val2) { return val1 >= val2 - EPSILON && val1 <= val2 + EPSILON; }
bool vec3eq(vec3 val1, vec3 val2) { return floateq(val1.r, val2.r) && floateq(val1.g, val2.g) && floateq(val1.b, val2.b); }

// Author: Michael Pohoreski https://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader
float random(vec2 seed){ return fract(cos(dot(seed, vec2(23.14069263277926, 2.665144142690225))) * 12345.6789); }
float snoise3(vec2 seed) { return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453); }
float randf_range(vec2 seed, float b1, float b2) { return mix(b1, b2, random(seed)); }
int randi_range(vec2 seed, int b1, int b2) { return int(randf_range(seed, float(b1), float(b2))); }
float sin0to1(float time) { return (sin(time)+1.0)/2.0; }
float cos0to1(float time) { return (cos(time)+1.0)/2.0; } 
float vary0to1(float time) { return 1.0-(cos(time)+1.0)/2.0; } // a transformed cos function that varies from 0 to 1. f(0) = 0, f(pi) = 1, f(2pi) = 0. 

uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;

uniform bool POST_PROCESSING = false;

// pass in the mouse position here
uniform vec2 MOUSE = vec2(20, 20);

uniform bool DISABLE = false;

// --- Effects --- //
// EXCLUDE
// If use_exclude_colors, pixels of these colors are excluded from tint, color correction, scanline, and vignette effects.
group_uniforms Exclude;
uniform bool use_exclude_colors = true;
uniform vec3 exclude_color1: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color2: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color3: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color4: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders

// PAN/DISPLACE
// Displaces all pixels by (displace_x, displace_y). Texture repeats if displace_repeat.
// WARNING - Offsetting beyond the bounds of the texture will result in the texture being cut off
group_uniforms PanAndDisplacement;
uniform int displace_x = 0;
uniform int displace_y = 0;
uniform bool displace_repeat = true;
// Texture will automatically scroll if auto_pan_speed is nonzero.
// Set auto_pan_speed to a positive number for left/up panning; negative number for right/down panning
// WARNING - Repeat generally should be true for auto_pan_speed, otherwise it will immediately pan out of view
uniform vec2 auto_pan_speed = vec2(0, 0);

// RECOLOR
// Replaces replace_colorN with replace_with_colorN.
group_uniforms Recolor;
uniform vec3 replace_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color5: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color5: source_color = vec3(0.0, 0.0, 0.0);
// special extra uniform specifically intended to recolor outlines
uniform vec3 replace_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 replace_with_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392);

// RECOLOR OSCILLATE
// Pixels of replace_color_oscillate_from oscillate between their original color and replace_color_oscillate_to at replace_color_oscillate_speed.
group_uniforms RecolorOscillate;
uniform vec3 auto_replace_color: source_color = vec3(0.0, 0.0, 0.0);
uniform bool auto_replace_replace_original_color = false;
uniform vec3 auto_replace_replace_original_color_with: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 auto_replace_to_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float auto_replace_speed: hint_range(0.0, 30.0) = 0.0;
uniform float auto_replace_start_time = 0.0;

// TINT
// Tint the texture with tint_color.
// The strength of the tint is controlled by tint_strength.
group_uniforms Tint;
uniform vec3 tint_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float tint_strength: hint_range(0.0, 1.0) = 0.0;

// FLASH
// Flash the texture with flash_color. Essentially, this is a second layer of tint.
// flash_strength controls how much color is the original and how much is the flash_color.
group_uniforms Flash;
uniform vec3 flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float flash_strength: hint_range(0.0, 1.0) = 0.0;
// auto_flash_speed will cause infinite and repeated flashing in auto_flash_color if nonzero and controls the speed of this flashing.
// auto_flash_bound1 and auto_flash_bound2 provide the bounds of the flashing effect.
// To prevent the auto flash from starting in the middle of the animation, set auto_flash_start_time to the global time when enabling auto flash.
// TIP - auto flash and regular ('manual') flash stack, which is why they have two separate colors.
uniform vec3 auto_flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float auto_flash_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flash_bound1: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flash_bound2: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flash_start_time = 0.0;

// COLOR CORRECTION
group_uniforms ColorCorrection;
// Applies red, green, or blue color correction with red_correct, green_correct, and blue_correct. 
// Applies grayscale with gray_correct.
// Modify brightness, contrast, or saturation with brightness_correct, contrast_correct, and saturation_correct.
// TIP - these values can actually go higher or lower, if you want a more extreme effect
uniform float red_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float green_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float blue_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float gray_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float brightness_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float contrast_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float saturation_correct: hint_range(0.0, 2.0, 0.01) = 1.0;

// TODO - more funky color options
// rg swap - swaps the original (before any other swaps) value of r and g
// gb swap
// br swap
// r_eq_g - sets r = g
// r_eq_b
// g_eq_r
// g_eq_b
// b_eq_r
// b_eq_g

// TODO - ROUGHEN - applies randomized brightness modifications across the texture (both positive and negative) to 'roughen' it up

// SCANLINES
// Create a line across the canvas of scanline_color. scanline_strength controls the alpha of the line.
// Define the position of the line with scanline_left_to_right_position, scanline_top_to_bottom_position,
// scanline_topleft_to_bottomright_position, and scanline_topright_to_bottomleft_position.
// The line is vertical if going left to right, horizontal if going top to bottom, and diagonal for the other two.
group_uniforms Scanline;
uniform vec3 scanline_color: source_color = vec3(0.98, 0.69, 0.23);
uniform float scanline_strength: hint_range(0.0, 1.0, 0.01) = 1.0;
uniform float scanline_left_to_right_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_top_to_bottom_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topleft_to_bottomright_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topright_to_bottomleft_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
// auto_scanline_DIRECTION_on will enable automatic repeating scanlines in that direction.
// auto_scanline_DIRECTION_reverse will flip the direction.
// The scan will be visible for auto_scanline_DIRECTION_scan_duration, with a delay of 
// auto_scanline_DIRECTION_scan_duration before the next scan begins.
// To prevent the scanline from starting in the middle of the texture, provide the global time to auto_scanline_DIRECTION_start_time.
uniform bool auto_scanline_left_to_right_on = false;
uniform bool auto_scanline_left_to_right_reverse = false;
uniform float auto_scanline_left_to_right_start_time = 0.0;
uniform float auto_scanline_left_to_right_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_left_to_right_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_top_to_bottom_on = false;
uniform bool auto_scanline_top_to_bottom_reverse = false;
uniform float auto_scanline_top_to_bottom_start_time = 0.0;
uniform float auto_scanline_top_to_bottom_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_top_to_bottom_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topleft_to_bottomright_on = false;
uniform bool auto_scanline_topleft_to_bottomright_reverse = false;
uniform float auto_scanline_topleft_to_bottomright_start_time = 0.0;
uniform float auto_scanline_topleft_to_bottomright_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topleft_to_bottomright_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topright_to_bottomleft_on = false;
uniform bool auto_scanline_topright_to_bottomleft_reverse = false;
uniform float auto_scanline_topright_to_bottomleft_start_time = 0.0;
uniform float auto_scanline_topright_to_bottomleft_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topright_to_bottomleft_delay: hint_range(0.0, 10.0, 0.01) = 1.0;

// OUTLINE
// Adds a pixel outline to the texture, with glow_color and glow_thickness.
// glow_dialgonals controls if we also create this outline diagonally, which makes it thicker.
// This can be used to create a solid outline if auto_glow_speed is left at 0.
// WARNING - Shaders cannot draw outside of the bounds of the canvas, so the canvas may need extra transparent space on the sides.
// WARNING - Can have some odd effects with sprites containing partial transparency.
group_uniforms GlowAndOutline;
uniform vec4 glow_color: source_color = vec4(1.0);
uniform int glow_thickness: hint_range(0, 10) = 0;
uniform bool glow_diagonals = false;
// auto_glow_speed defines the speed of a glow fluctuating alpha between the outline's alpha and auto_glow_bound at auto_glow_speed.
// To prevent the auto glow from starting in the middle of the animation, set auto_glow_start_time to the global time when enabling auto glow.
uniform float auto_glow_speed: hint_range(0.0, 30.0) = 0.0;
uniform float auto_glow_bound: hint_range(0.0, 1.0) = 0.75;
uniform float auto_glow_start_time = 0.0;

// DISINTEGRATE
// Sets 'random' pixels in the canvas to disintegrate_color with alpha between disintegrate_alpha_bound1 and disintegrate_alpha_bound2.
// By default, since these bounds are 0, the pixels will be made fully transparent and therefore disintegrate_color is unused.
// disintegrate_strength controls the amount of pixels affected, from none (0) to all of them (1).
// Change the pattern via disintegrate_seed.
// disintegrate_as_static changes the purpose of disintegrate to not affect the alpha of the texture.
// Instead, it layers a static-looking pattern on top using disintegrate_color, where the color is based on disintegrate_color
// and the alpha of the static pattern ranges randomly between disintegrate_alpha_bound1 and disintegrate_alpha_bound2 per pixel.
// Note that with the default bounds of 0 and 0, this setting creates no effect whatsoever.
// If auto_disintegrate_random_seed_speed is nonzero, applies randomization to the seed over time based on speed.
// In this case, disintegrate_seed has no effect.
group_uniforms Disintegrate;
uniform int disintegrate_seed = 1;
uniform vec3 disintegrate_color : source_color = vec3(0.0, 0.0, 0.0);
uniform float disintegrate_strength: hint_range(0.0, 1.0) = 0.0;
uniform float disintegrate_alpha_bound1 = 0.0;
uniform float disintegrate_alpha_bound2 = 0.0;
uniform bool disintegrate_as_static = false;
uniform float auto_disintegrate_random_seed_speed: hint_range(0.0, 1.0) = 0.0;

// FOG
// Applies a fog_noise_texture filter over the texture with modifiable fog_opacity and fog_density, moving at fog_speed
// Mostly used to create fog effects by assigning to a ColorRect (color is changable by changing ColorRect color too!)
// NOTE - Don't use this as a post processing shader. 
group_uniforms Fog;
uniform bool fog_enabled = false;
uniform sampler2D fog_noise_texture: repeat_enable, filter_nearest;
uniform float fog_opacity: hint_range(0.0, 1.0) = 0.5;
uniform float fog_density: hint_range(0.0, 1.0) = 0.25;
uniform vec2 fog_speed = vec2(-0.02, 0.0);

// COLORLINES
// Creates vertical/horizontal lines of colorline_color spaced colorline_spacing pixels apart 
// with colorline_strength alpha across the texture.
group_uniforms Colorlines;
uniform vec3 vertical_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int vertical_colorline_spacing = 2;
uniform float vertical_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;
uniform vec3 horizontal_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int horizontal_colorline_spacing = 2;
uniform float horizontal_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;

// CHECKER
// Creates a checkerboard pattern across the texture of checker_color with checker_strength alpha.
// checker_x_size and checker_y_size defines the size of each rectangular checker
// checker_x_pattern and checker_y_pattern affect the pattern of the checker pattern (which
// can stop looking checkered with different values).
// checker_contrast_amount applies a darkening effect to pixels of the checkerboard that are already dark.
// checker_contrast_ratio increases the contrast of the darkening effect between light and dark colored pixels,
// ie dark pixels become even darker.
group_uniforms CHECKER;
uniform vec3 checker_color: source_color = vec3(0.2, 0.2, 0.2);
uniform float checker_strength: hint_range(0.0, 1.0, 0.01) = 0.0; //0.3 is a good one
uniform int checker_x_size: hint_range(1, 64, 1) = 1;
uniform int checker_y_size: hint_range(1, 64, 1) = 1;
uniform int checker_x_pattern: hint_range(1, 32, 1) = 2;
uniform int checker_y_pattern: hint_range(1, 32, 1) = 2;
uniform float checker_contrast_amount: hint_range(-10.0, 10.0, 0.1) = 1.0;
uniform float checker_contrast_ratio: hint_range(0.0, 10.0, 0.01) = 0.5;
// TODO - experiment a bit more with the contrast calculation here - maybe subtract 0.5 and LIGHTEN lighter areas?

// MOUSELIGHT
// Creates a circular lighting effect at the mouse's position if mouselight_on, of mouselight_color and mouselight_strength alpha.
// Mouselight size defines the radius of the light effect.
// If mouselight_soften_edges, pixels further from the center of the light are more transparent.
// If mouselight_checker, the effect will be checkered in a way that interacts with the CHECKER effect.
// If auto_mouselight_flicker_speed is non-zero, the light will oscillate in size between mouselight_size and auto_mouselight_flicker_speed
group_uniforms Mouselight;
uniform bool mouselight_on = false;
uniform vec3 mouselight_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float mouselight_strength = 0.5;
uniform int mouselight_size = 8;
uniform bool mouselight_soften_edges = true;
uniform bool mouselight_checker = false;
uniform float auto_mouselight_flicker_speed: hint_range(0.0, 20.0) = 8;
uniform float auto_mouselight_flicker_bound = 10;

// CUT
// Cuts off all pixels of the texture from left/right/top/bottom.
group_uniforms Cut;
uniform float cut_left: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_right: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_top: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_bottom: hint_range(0.0, 1.0, 0.001) = 0.0;

// VIGNETTE
// Applies a circular vignette effect on the canvas if vignette_on.
// The vignette has a vignette_radius and a vignette_color.
// If vignette_ignore_transparent, transparent pixels will not have the vignette applied.
// This is generally useful if you want to apply a vignette on something besides the entire screen.
// Radius -> 0 tends to do some crazy effects
group_uniforms Vignette;
uniform bool vignette_on = false;
uniform bool vignette_ignore_transparent = false;
uniform vec3 vignette_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float vignette_radius: hint_range(0.001, 20.0, 0.01) = 1.0;

// TRANSPARENCY
// Controls transparency of the texture.
// If auto_flicker_speed is not zero, oscillates between transparency and auto_flicker_bounds at auto_flicker_speed.
// To prevent the auto flicker from starting in the middle of the animation, set auto_flicker_start_time to the global time when enabling auto flicker.
group_uniforms Transparency;
uniform float transparency: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flicker_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flicker_bound: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flicker_start_time = 0.0;

// --- Fragment Shader --- //
void fragment() 
{
	if (!DISABLE) {
	
	COLOR = texture(TEXTURE, UV);
	
	// --- CALCULATE CONSTANTS ---
	// WARNING - Don't use the ones with _ directly. 
	// the size of this canvas in pixels (ex 10x10)
	int _SIZE_IN_PIXELS_X = int(floor(1.0 / TEXTURE_PIXEL_SIZE.x));
	int _SIZE_IN_PIXELS_Y = int(floor(1.0 / TEXTURE_PIXEL_SIZE.y));
	// the size of the screen in pixels (ex 320x180)
	int _SCREEN_SIZE_IN_PIXELS_X = int(floor(1.0 / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_SIZE_IN_PIXELS_Y = int(floor(1.0 / SCREEN_PIXEL_SIZE.y));
	
	// the specific x and y pixel coordinates within texture
	int _PIXEL_X = int(floor(UV.x / TEXTURE_PIXEL_SIZE.x));
	int _PIXEL_Y = int(floor(UV.y / TEXTURE_PIXEL_SIZE.y));
	// the specific x and y pixel coordinates within screen
	int _SCREEN_PIXEL_X = int(floor(SCREEN_UV.x / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_PIXEL_Y = int(floor(SCREEN_UV.y / SCREEN_PIXEL_SIZE.y));
	
	// WARNING - Use these instead. This accounts for if this is a normal or post processing shader.
	// Size of a pixel for this canvas (ie 1/320x1/180)
	float PIXEL_SIZE_X = POST_PROCESSING ? SCREEN_PIXEL_SIZE.x : TEXTURE_PIXEL_SIZE.x;
	float PIXEL_SIZE_Y = POST_PROCESSING ? SCREEN_PIXEL_SIZE.y : TEXTURE_PIXEL_SIZE.y;
	// Size of the canvas in pixels. (ex 320x180)
	int SIZE_IN_PIXELS_X = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_X : _SIZE_IN_PIXELS_X;
	int SIZE_IN_PIXELS_Y = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_Y : _SIZE_IN_PIXELS_Y;
	// The specific XY coordinates of the current pixel.
	int X = POST_PROCESSING ? _SCREEN_PIXEL_X : _PIXEL_X;
	int Y = POST_PROCESSING ? _SCREEN_PIXEL_Y : _PIXEL_Y;
	// UV coordinates of the current pixel.
	vec2 MUV = POST_PROCESSING ? SCREEN_UV : UV;
	// ---
	
	
	// DISPLACE & PAN
	vec2 adjUV = vec2(0, 0); // WARNING - Use this instead of UV below, otherwise effects break with panning & displace
	
	float displaceUVX = MUV.x + (SCREEN_PIXEL_SIZE.x * float(displace_x));
	float displaceUVY = MUV.y + (SCREEN_PIXEL_SIZE.y * float(displace_y));
	if (displace_repeat) {
		adjUV = mod(vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed, 1.00000);
	} else {
		adjUV = vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed;
	}
	
	// $HACK$ doing this as a ternary breaks the preview, for some reason
	if (POST_PROCESSING) 
		COLOR = texture(SCREEN_TEXTURE, adjUV);
	else 
		COLOR = texture(TEXTURE, adjUV);
	
	// EXCLUDE COLORS
	bool is_exclude_color = use_exclude_colors && (vec3eq(COLOR.rgb, exclude_color1) || vec3eq(COLOR.rgb, exclude_color2) || vec3eq(COLOR.rgb, exclude_color3) || vec3eq(COLOR.rgb, exclude_color4));
	
	// RECOLOR
	if (vec3eq(COLOR.rgb, replace_color1)) 
		COLOR.rgb = replace_with_color1;
	if (vec3eq(COLOR.rgb, replace_color2)) 
		COLOR.rgb = replace_with_color2;
	if (vec3eq(COLOR.rgb, replace_color3)) 
		COLOR.rgb = replace_with_color3;
	if (vec3eq(COLOR.rgb, replace_color4)) 
		COLOR.rgb = replace_with_color4;
	if (vec3eq(COLOR.rgb, replace_color5)) 
		COLOR.rgb = replace_with_color5;
	if (vec3eq(COLOR.rgb, replace_color_outline))
		COLOR.rgb = replace_with_color_outline;
	
	if (vec3eq(COLOR.rgb, auto_replace_color)) {
		vec3 replaced = auto_replace_color;
		if (auto_replace_replace_original_color)
			replaced = auto_replace_replace_original_color_with;
		COLOR.rgb  = mix(replaced, auto_replace_to_color, abs(vary0to1((TIME-auto_replace_start_time + TIME_OFFSET) * auto_replace_speed)));
	}
	
	// TINT, COLOR CORRECTION, and SCANLINE ignore excluded colors
	if (!is_exclude_color) {
		// TINT
		COLOR.rgb = mix(COLOR.rgb, tint_color, tint_strength);

		// FLASH
		// apply automatic flash
		if (auto_flash_speed != 0.0) {
			float auto_strength = mix(auto_flash_bound1, auto_flash_bound2, abs(vary0to1((TIME-auto_flash_start_time + TIME_OFFSET) * auto_flash_speed)));
			COLOR.rgb = mix(COLOR.rgb, auto_flash_color, auto_strength);
		}
		// apply manual flash
		COLOR.rgb = mix(COLOR.rgb, flash_color, flash_strength);

		// COLOR CORRECTION
		COLOR.r = mix(COLOR.r, 1.0, red_correct);
		COLOR.g = mix(COLOR.g, 1.0, green_correct);
		COLOR.b = mix(COLOR.b, 1.0, blue_correct);
		COLOR.rgb = mix(COLOR.rgb, vec3(0.2126 * COLOR.r + 0.7152 * COLOR.g + 0.0722 * COLOR.b), gray_correct);
		COLOR.rgb = mix(vec3(0.0), COLOR.rgb, brightness_correct);
		COLOR.rgb = mix(vec3(0.5), COLOR.rgb, contrast_correct);
		COLOR.rgb = mix(vec3(dot(vec3(1.0), COLOR.rbg)), COLOR.rgb, saturation_correct);

		// SCANLINE
		// FIX
		if (COLOR.a != 0.0) {
			float l_to_r_pos = !auto_scanline_left_to_right_on ? scanline_left_to_right_position : abs((auto_scanline_left_to_right_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_left_to_right_start_time + TIME_OFFSET, auto_scanline_left_to_right_delay + auto_scanline_left_to_right_scan_duration), 0.0, auto_scanline_left_to_right_scan_duration)/auto_scanline_left_to_right_scan_duration)));
			float t_to_b_pos = !auto_scanline_top_to_bottom_on ? scanline_top_to_bottom_position : abs((auto_scanline_top_to_bottom_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_top_to_bottom_start_time + TIME_OFFSET, auto_scanline_top_to_bottom_delay + auto_scanline_top_to_bottom_scan_duration), 0.0, auto_scanline_top_to_bottom_scan_duration)/auto_scanline_top_to_bottom_scan_duration)));
			float tl_to_br_pos = !auto_scanline_topleft_to_bottomright_on ? scanline_topleft_to_bottomright_position : abs((auto_scanline_topleft_to_bottomright_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topleft_to_bottomright_start_time + TIME_OFFSET, auto_scanline_topleft_to_bottomright_delay + auto_scanline_topleft_to_bottomright_scan_duration), 0.0, auto_scanline_topleft_to_bottomright_scan_duration)/auto_scanline_topleft_to_bottomright_scan_duration)));
			float tr_to_bl_pos = !auto_scanline_topright_to_bottomleft_on ? scanline_topright_to_bottomleft_position : abs((auto_scanline_topright_to_bottomleft_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topright_to_bottomleft_start_time + TIME_OFFSET, auto_scanline_topright_to_bottomleft_delay + auto_scanline_topright_to_bottomleft_scan_duration), 0.0, auto_scanline_topright_to_bottomleft_scan_duration)/auto_scanline_topright_to_bottomleft_scan_duration)));

			if (X == int(floor(l_to_r_pos / float(PIXEL_SIZE_X))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (Y == int(floor(t_to_b_pos / float(PIXEL_SIZE_Y))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			int scanline_target_tlbr = int(floor(tl_to_br_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y)));
			int scanline_target_trbl = int(floor(tr_to_bl_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y))) - SIZE_IN_PIXELS_Y;
			if (X+Y == scanline_target_tlbr)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (X-Y == scanline_target_trbl)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
		}
	}

	// GLOW
	if (glow_thickness != 0) {
		vec2 outline_size = TEXTURE_PIXEL_SIZE * float(glow_thickness);
		float outline = 0.0;
		for (int i = 0; i < HORIZONTAL_VERTICAL_OFFSETS.length(); i++) {
			outline += texture(TEXTURE, adjUV + outline_size * HORIZONTAL_VERTICAL_OFFSETS[i]).a;
		}
		if (glow_diagonals) {
			for (int i = 0; i < DIAGONAL_OUTLINE_OFFSETS.length(); i++) {
				outline += texture(TEXTURE, adjUV + outline_size * DIAGONAL_OUTLINE_OFFSETS[i]).a;
			}
		}
		outline = min(outline, 1.0);
		// this is a bit of a coding $HACK$ to make auto_glow_bound do nothing if auto_glow_speed is 0, but it definitely works
		float alp = auto_glow_speed == 0.0 ? 1.0 : mix(auto_glow_bound, glow_color.a, vary0to1((TIME - auto_glow_start_time + TIME_OFFSET) * auto_glow_speed));
		COLOR = mix(COLOR, glow_color * alp, outline - COLOR.a);
	}

	// DISINTEGRATE
	if (!is_exclude_color && COLOR.a != 0.0) {
		vec2 s = adjUV * vec2(float(disintegrate_seed));
		s *= auto_disintegrate_random_seed_speed != 0.0 ? float(int(TIME / mix(1.0, 0.001, auto_disintegrate_random_seed_speed))) : 1.0;
		float r = random(s);
		if (r < disintegrate_strength) {
			float r_alpha = randf_range(s, disintegrate_alpha_bound1, disintegrate_alpha_bound2);
			COLOR.rgb = mix(COLOR.rgb, disintegrate_color, r_alpha);
			if (!disintegrate_as_static)
				COLOR.a = r_alpha;
		}
	}

	// FOG
	if (fog_enabled) {
		vec2 fog_uv = MUV + fog_speed * TIME;
		float noise_alpha = texture(fog_noise_texture, fog_uv).r;
		// Convert noise from (0.0, 1.0) to (-1.0, 1.0)
		float fog = clamp((noise_alpha * 2.0 - 1.0) + (fog_density * 2.0), 0.0, 1.0);
		COLOR.a *= fog * fog_opacity;
	}

	// COLORLINES	
	if (!is_exclude_color) {
		if (X % vertical_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, vertical_colorline_color, vertical_colorline_strength);
		}
		if (Y % horizontal_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, horizontal_colorline_color, horizontal_colorline_strength);
		}
	}

	// CHECKER
	if (!is_exclude_color) {	
		if (X/checker_x_size % checker_x_pattern != Y/checker_y_size % checker_y_pattern) {
			float pixel_darkness = (3.0 - (COLOR.r + COLOR.g + COLOR.b)) * checker_contrast_ratio; // calculates 0.0 to 1.0 where 1.0 is pure black and 0.0 is pure white
			vec3 cbcolor = mix(checker_color.rgb, vec3(0.0), pixel_darkness * checker_contrast_amount);
			COLOR.rgb = mix(COLOR.rgb, cbcolor, checker_strength);
		}
	}

	// MOUSELIGHT
	if (mouselight_on && (!mouselight_checker || X % 2 == Y % 2)) {
		float mouse_with_flicker = mix(auto_mouselight_flicker_bound, float(mouselight_size), vary0to1(TIME * auto_mouselight_flicker_speed));
		float dist_from_mouse = sqrt(pow(float(_SCREEN_PIXEL_X - int(MOUSE.x)), 2.0) + pow(float(_SCREEN_PIXEL_Y - int(MOUSE.y)), 2.0));
		if (dist_from_mouse <= float(mouse_with_flicker)) {
			//todo - make softening with distance optional as uniform
			float distance_mod = clamp((mouse_with_flicker - dist_from_mouse) / mouse_with_flicker, 0.0, 1.0);
			COLOR.rgb = mix(COLOR.rgb, mouselight_color, distance_mod * mouselight_strength);
		}
	}

	// CUT
	if (MUV.x < cut_left)
		COLOR.a = 0.0;
	if (MUV.x > 1.0-cut_right)
		COLOR.a = 0.0;
	if (MUV.y < cut_top)
		COLOR.a = 0.0;
	if (MUV.y > 1.0-cut_bottom)
		COLOR.a = 0.0;

	// VIGNETTE
	if (vignette_on && ((!vignette_ignore_transparent || COLOR.a != 0.0)) && !is_exclude_color) {
		float x = abs(adjUV.x-.5)*2.0;
		float y = abs(adjUV.y-.5)*2.0;
		float v = (sqrt((x*x)+(y*y))/vignette_radius);
		COLOR = mix(COLOR, vec4(vignette_color.r, vignette_color.g, vignette_color.b, 1.0), v);
	}

	// TRANSPARENCY
	if (COLOR.a != 0.0) {
		COLOR.a = mix(COLOR.a * transparency, auto_flicker_bound, vary0to1((TIME-auto_flicker_start_time + TIME_OFFSET) * auto_flicker_speed));
	}
	
	} //end if disable
}

void vertex()
{
	
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_e7dsc"]
shader = SubResource("Shader_fmgy3")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0.435294, 0.337255, 0.992157, 1)
shader_parameter/tint_strength = 1.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(0.364706, 0.0941176, 0.972549, 1)
shader_parameter/auto_flash_speed = 3.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 0.75
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(-0.02, 0)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 8.0
shader_parameter/auto_mouselight_flicker_bound = 10.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 0.1
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="Shader" id="Shader_l6nco"]
code = "// Ben's Uber Pixel Shader
// WARNING - Shader expects uniform inputs in the range 0.0 - 1.0 for Colors. 
//           Therefore, be sure that Colors being passed in are in the correct range of (0-1, 0-1, 0-1, 0-1).
shader_type canvas_item;

// --- Utilty Functions --- //
const bool DEBUG = true;
const float TIME_OFFSET = 10.0; //offset all start times by this... for some reason things line up better with expectations
const vec2 HORIZONTAL_VERTICAL_OFFSETS[4] = {vec2(0, 1), vec2(-1, 0), vec2(1, 0), vec2(0, -1)};
const vec2 DIAGONAL_OUTLINE_OFFSETS[4] = {vec2(1, 1), vec2(-1, 1), vec2(1, -1), vec2(-1, -1)};

// checks if two values are 'equal' (within EPSILON of each other)
// necessary when doing float calculations since it's not perfectly precise
const float EPSILON = 0.001;
bool floateq(float val1, float val2) { return val1 >= val2 - EPSILON && val1 <= val2 + EPSILON; }
bool vec3eq(vec3 val1, vec3 val2) { return floateq(val1.r, val2.r) && floateq(val1.g, val2.g) && floateq(val1.b, val2.b); }

// Author: Michael Pohoreski https://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader
float random(vec2 seed){ return fract(cos(dot(seed, vec2(23.14069263277926, 2.665144142690225))) * 12345.6789); }
float snoise3(vec2 seed) { return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453); }
float randf_range(vec2 seed, float b1, float b2) { return mix(b1, b2, random(seed)); }
int randi_range(vec2 seed, int b1, int b2) { return int(randf_range(seed, float(b1), float(b2))); }
float sin0to1(float time) { return (sin(time)+1.0)/2.0; }
float cos0to1(float time) { return (cos(time)+1.0)/2.0; } 
float vary0to1(float time) { return 1.0-(cos(time)+1.0)/2.0; } // a transformed cos function that varies from 0 to 1. f(0) = 0, f(pi) = 1, f(2pi) = 0. 

uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;

uniform bool POST_PROCESSING = false;

// pass in the mouse position here
uniform vec2 MOUSE = vec2(20, 20);

uniform bool DISABLE = false;

// --- Effects --- //
// EXCLUDE
// If use_exclude_colors, pixels of these colors are excluded from tint, color correction, scanline, and vignette effects.
group_uniforms Exclude;
uniform bool use_exclude_colors = true;
uniform vec3 exclude_color1: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color2: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color3: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 exclude_color4: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders

// PAN/DISPLACE
// Displaces all pixels by (displace_x, displace_y). Texture repeats if displace_repeat.
// WARNING - Offsetting beyond the bounds of the texture will result in the texture being cut off
group_uniforms PanAndDisplacement;
uniform int displace_x = 0;
uniform int displace_y = 0;
uniform bool displace_repeat = true;
// Texture will automatically scroll if auto_pan_speed is nonzero.
// Set auto_pan_speed to a positive number for left/up panning; negative number for right/down panning
// WARNING - Repeat generally should be true for auto_pan_speed, otherwise it will immediately pan out of view
uniform vec2 auto_pan_speed = vec2(0, 0);

// RECOLOR
// Replaces replace_colorN with replace_with_colorN.
group_uniforms Recolor;
uniform vec3 replace_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color1: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color2: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color3: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color4: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_color5: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 replace_with_color5: source_color = vec3(0.0, 0.0, 0.0);
// special extra uniform specifically intended to recolor outlines
uniform vec3 replace_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392); // these floats are the numbers I like to use for borders
uniform vec3 replace_with_color_outline: source_color = vec3(0.07843137254, 0.06274509803, 0.07450980392);

// RECOLOR OSCILLATE
// Pixels of replace_color_oscillate_from oscillate between their original color and replace_color_oscillate_to at replace_color_oscillate_speed.
group_uniforms RecolorOscillate;
uniform vec3 auto_replace_color: source_color = vec3(0.0, 0.0, 0.0);
uniform bool auto_replace_replace_original_color = false;
uniform vec3 auto_replace_replace_original_color_with: source_color = vec3(0.0, 0.0, 0.0);
uniform vec3 auto_replace_to_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float auto_replace_speed: hint_range(0.0, 30.0) = 0.0;
uniform float auto_replace_start_time = 0.0;

// TINT
// Tint the texture with tint_color.
// The strength of the tint is controlled by tint_strength.
group_uniforms Tint;
uniform vec3 tint_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float tint_strength: hint_range(0.0, 1.0) = 0.0;

// FLASH
// Flash the texture with flash_color. Essentially, this is a second layer of tint.
// flash_strength controls how much color is the original and how much is the flash_color.
group_uniforms Flash;
uniform vec3 flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float flash_strength: hint_range(0.0, 1.0) = 0.0;
// auto_flash_speed will cause infinite and repeated flashing in auto_flash_color if nonzero and controls the speed of this flashing.
// auto_flash_bound1 and auto_flash_bound2 provide the bounds of the flashing effect.
// To prevent the auto flash from starting in the middle of the animation, set auto_flash_start_time to the global time when enabling auto flash.
// TIP - auto flash and regular ('manual') flash stack, which is why they have two separate colors.
uniform vec3 auto_flash_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float auto_flash_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flash_bound1: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flash_bound2: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flash_start_time = 0.0;

// COLOR CORRECTION
group_uniforms ColorCorrection;
// Applies red, green, or blue color correction with red_correct, green_correct, and blue_correct. 
// Applies grayscale with gray_correct.
// Modify brightness, contrast, or saturation with brightness_correct, contrast_correct, and saturation_correct.
// TIP - these values can actually go higher or lower, if you want a more extreme effect
uniform float red_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float green_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float blue_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float gray_correct: hint_range(-1.0, 1.0, 0.01) = 0.0;
uniform float brightness_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float contrast_correct: hint_range(0.0, 5.0, 0.01) = 1.0;
uniform float saturation_correct: hint_range(0.0, 2.0, 0.01) = 1.0;

// TODO - more funky color options
// rg swap - swaps the original (before any other swaps) value of r and g
// gb swap
// br swap
// r_eq_g - sets r = g
// r_eq_b
// g_eq_r
// g_eq_b
// b_eq_r
// b_eq_g

// TODO - ROUGHEN - applies randomized brightness modifications across the texture (both positive and negative) to 'roughen' it up

// SCANLINES
// Create a line across the canvas of scanline_color. scanline_strength controls the alpha of the line.
// Define the position of the line with scanline_left_to_right_position, scanline_top_to_bottom_position,
// scanline_topleft_to_bottomright_position, and scanline_topright_to_bottomleft_position.
// The line is vertical if going left to right, horizontal if going top to bottom, and diagonal for the other two.
group_uniforms Scanline;
uniform vec3 scanline_color: source_color = vec3(0.98, 0.69, 0.23);
uniform float scanline_strength: hint_range(0.0, 1.0, 0.01) = 1.0;
uniform float scanline_left_to_right_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_top_to_bottom_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topleft_to_bottomright_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
uniform float scanline_topright_to_bottomleft_position: hint_range(-0.001, 1.0, 0.001) = -0.001;
// auto_scanline_DIRECTION_on will enable automatic repeating scanlines in that direction.
// auto_scanline_DIRECTION_reverse will flip the direction.
// The scan will be visible for auto_scanline_DIRECTION_scan_duration, with a delay of 
// auto_scanline_DIRECTION_scan_duration before the next scan begins.
// To prevent the scanline from starting in the middle of the texture, provide the global time to auto_scanline_DIRECTION_start_time.
uniform bool auto_scanline_left_to_right_on = false;
uniform bool auto_scanline_left_to_right_reverse = false;
uniform float auto_scanline_left_to_right_start_time = 0.0;
uniform float auto_scanline_left_to_right_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_left_to_right_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_top_to_bottom_on = false;
uniform bool auto_scanline_top_to_bottom_reverse = false;
uniform float auto_scanline_top_to_bottom_start_time = 0.0;
uniform float auto_scanline_top_to_bottom_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_top_to_bottom_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topleft_to_bottomright_on = false;
uniform bool auto_scanline_topleft_to_bottomright_reverse = false;
uniform float auto_scanline_topleft_to_bottomright_start_time = 0.0;
uniform float auto_scanline_topleft_to_bottomright_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topleft_to_bottomright_delay: hint_range(0.0, 10.0, 0.01) = 1.0;
uniform bool auto_scanline_topright_to_bottomleft_on = false;
uniform bool auto_scanline_topright_to_bottomleft_reverse = false;
uniform float auto_scanline_topright_to_bottomleft_start_time = 0.0;
uniform float auto_scanline_topright_to_bottomleft_scan_duration: hint_range(0.1, 5.0, 0.01) = 0.5;
uniform float auto_scanline_topright_to_bottomleft_delay: hint_range(0.0, 10.0, 0.01) = 1.0;

// OUTLINE
// Adds a pixel outline to the texture, with glow_color and glow_thickness.
// glow_dialgonals controls if we also create this outline diagonally, which makes it thicker.
// This can be used to create a solid outline if auto_glow_speed is left at 0.
// WARNING - Shaders cannot draw outside of the bounds of the canvas, so the canvas may need extra transparent space on the sides.
// WARNING - Can have some odd effects with sprites containing partial transparency.
group_uniforms GlowAndOutline;
uniform vec4 glow_color: source_color = vec4(1.0);
uniform int glow_thickness: hint_range(0, 10) = 0;
uniform bool glow_diagonals = false;
// auto_glow_speed defines the speed of a glow fluctuating alpha between the outline's alpha and auto_glow_bound at auto_glow_speed.
// To prevent the auto glow from starting in the middle of the animation, set auto_glow_start_time to the global time when enabling auto glow.
uniform float auto_glow_speed: hint_range(0.0, 30.0) = 0.0;
uniform float auto_glow_bound: hint_range(0.0, 1.0) = 0.75;
uniform float auto_glow_start_time = 0.0;

// DISINTEGRATE
// Sets 'random' pixels in the canvas to disintegrate_color with alpha between disintegrate_alpha_bound1 and disintegrate_alpha_bound2.
// By default, since these bounds are 0, the pixels will be made fully transparent and therefore disintegrate_color is unused.
// disintegrate_strength controls the amount of pixels affected, from none (0) to all of them (1).
// Change the pattern via disintegrate_seed.
// disintegrate_as_static changes the purpose of disintegrate to not affect the alpha of the texture.
// Instead, it layers a static-looking pattern on top using disintegrate_color, where the color is based on disintegrate_color
// and the alpha of the static pattern ranges randomly between disintegrate_alpha_bound1 and disintegrate_alpha_bound2 per pixel.
// Note that with the default bounds of 0 and 0, this setting creates no effect whatsoever.
// If auto_disintegrate_random_seed_speed is nonzero, applies randomization to the seed over time based on speed.
// In this case, disintegrate_seed has no effect.
group_uniforms Disintegrate;
uniform int disintegrate_seed = 1;
uniform vec3 disintegrate_color : source_color = vec3(0.0, 0.0, 0.0);
uniform float disintegrate_strength: hint_range(0.0, 1.0) = 0.0;
uniform float disintegrate_alpha_bound1 = 0.0;
uniform float disintegrate_alpha_bound2 = 0.0;
uniform bool disintegrate_as_static = false;
uniform float auto_disintegrate_random_seed_speed: hint_range(0.0, 1.0) = 0.0;

// FOG
// Applies a fog_noise_texture filter over the texture with modifiable fog_opacity and fog_density, moving at fog_speed
// Mostly used to create fog effects by assigning to a ColorRect (color is changable by changing ColorRect color too!)
// NOTE - Don't use this as a post processing shader. 
group_uniforms Fog;
uniform bool fog_enabled = false;
uniform sampler2D fog_noise_texture: repeat_enable, filter_nearest;
uniform float fog_opacity: hint_range(0.0, 1.0) = 0.5;
uniform float fog_density: hint_range(0.0, 1.0) = 0.25;
uniform vec2 fog_speed = vec2(-0.02, 0.0);

// COLORLINES
// Creates vertical/horizontal lines of colorline_color spaced colorline_spacing pixels apart 
// with colorline_strength alpha across the texture.
group_uniforms Colorlines;
uniform vec3 vertical_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int vertical_colorline_spacing = 2;
uniform float vertical_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;
uniform vec3 horizontal_colorline_color: source_color = vec3(1.0, 1.0, 1.0);
uniform int horizontal_colorline_spacing = 2;
uniform float horizontal_colorline_strength: hint_range(0.0, 1.0, 0.01) = 0.0;

// CHECKER
// Creates a checkerboard pattern across the texture of checker_color with checker_strength alpha.
// checker_x_size and checker_y_size defines the size of each rectangular checker
// checker_x_pattern and checker_y_pattern affect the pattern of the checker pattern (which
// can stop looking checkered with different values).
// checker_contrast_amount applies a darkening effect to pixels of the checkerboard that are already dark.
// checker_contrast_ratio increases the contrast of the darkening effect between light and dark colored pixels,
// ie dark pixels become even darker.
group_uniforms CHECKER;
uniform vec3 checker_color: source_color = vec3(0.2, 0.2, 0.2);
uniform float checker_strength: hint_range(0.0, 1.0, 0.01) = 0.0; //0.3 is a good one
uniform int checker_x_size: hint_range(1, 64, 1) = 1;
uniform int checker_y_size: hint_range(1, 64, 1) = 1;
uniform int checker_x_pattern: hint_range(1, 32, 1) = 2;
uniform int checker_y_pattern: hint_range(1, 32, 1) = 2;
uniform float checker_contrast_amount: hint_range(-10.0, 10.0, 0.1) = 1.0;
uniform float checker_contrast_ratio: hint_range(0.0, 10.0, 0.01) = 0.5;
// TODO - experiment a bit more with the contrast calculation here - maybe subtract 0.5 and LIGHTEN lighter areas?

// MOUSELIGHT
// Creates a circular lighting effect at the mouse's position if mouselight_on, of mouselight_color and mouselight_strength alpha.
// Mouselight size defines the radius of the light effect.
// If mouselight_soften_edges, pixels further from the center of the light are more transparent.
// If mouselight_checker, the effect will be checkered in a way that interacts with the CHECKER effect.
// If auto_mouselight_flicker_speed is non-zero, the light will oscillate in size between mouselight_size and auto_mouselight_flicker_speed
group_uniforms Mouselight;
uniform bool mouselight_on = false;
uniform vec3 mouselight_color: source_color = vec3(1.0, 1.0, 1.0);
uniform float mouselight_strength = 0.5;
uniform int mouselight_size = 8;
uniform bool mouselight_soften_edges = true;
uniform bool mouselight_checker = false;
uniform float auto_mouselight_flicker_speed: hint_range(0.0, 20.0) = 8;
uniform float auto_mouselight_flicker_bound = 10;

// CUT
// Cuts off all pixels of the texture from left/right/top/bottom.
group_uniforms Cut;
uniform float cut_left: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_right: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_top: hint_range(0.0, 1.0, 0.001) = 0.0;
uniform float cut_bottom: hint_range(0.0, 1.0, 0.001) = 0.0;

// VIGNETTE
// Applies a circular vignette effect on the canvas if vignette_on.
// The vignette has a vignette_radius and a vignette_color.
// If vignette_ignore_transparent, transparent pixels will not have the vignette applied.
// This is generally useful if you want to apply a vignette on something besides the entire screen.
// Radius -> 0 tends to do some crazy effects
group_uniforms Vignette;
uniform bool vignette_on = false;
uniform bool vignette_ignore_transparent = false;
uniform vec3 vignette_color: source_color = vec3(0.0, 0.0, 0.0);
uniform float vignette_radius: hint_range(0.001, 20.0, 0.01) = 1.0;

// TRANSPARENCY
// Controls transparency of the texture.
// If auto_flicker_speed is not zero, oscillates between transparency and auto_flicker_bounds at auto_flicker_speed.
// To prevent the auto flicker from starting in the middle of the animation, set auto_flicker_start_time to the global time when enabling auto flicker.
group_uniforms Transparency;
uniform float transparency: hint_range(0.0, 1.0) = 1.0;
uniform float auto_flicker_speed: hint_range(0.0, 20.0) = 0.0;
uniform float auto_flicker_bound: hint_range(0.0, 1.0) = 0.0;
uniform float auto_flicker_start_time = 0.0;

// --- Fragment Shader --- //
void fragment() 
{
	if (!DISABLE) {
	
	COLOR = texture(TEXTURE, UV);
	
	// --- CALCULATE CONSTANTS ---
	// WARNING - Don't use the ones with _ directly. 
	// the size of this canvas in pixels (ex 10x10)
	int _SIZE_IN_PIXELS_X = int(floor(1.0 / TEXTURE_PIXEL_SIZE.x));
	int _SIZE_IN_PIXELS_Y = int(floor(1.0 / TEXTURE_PIXEL_SIZE.y));
	// the size of the screen in pixels (ex 320x180)
	int _SCREEN_SIZE_IN_PIXELS_X = int(floor(1.0 / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_SIZE_IN_PIXELS_Y = int(floor(1.0 / SCREEN_PIXEL_SIZE.y));
	
	// the specific x and y pixel coordinates within texture
	int _PIXEL_X = int(floor(UV.x / TEXTURE_PIXEL_SIZE.x));
	int _PIXEL_Y = int(floor(UV.y / TEXTURE_PIXEL_SIZE.y));
	// the specific x and y pixel coordinates within screen
	int _SCREEN_PIXEL_X = int(floor(SCREEN_UV.x / SCREEN_PIXEL_SIZE.x));
	int _SCREEN_PIXEL_Y = int(floor(SCREEN_UV.y / SCREEN_PIXEL_SIZE.y));
	
	// WARNING - Use these instead. This accounts for if this is a normal or post processing shader.
	// Size of a pixel for this canvas (ie 1/320x1/180)
	float PIXEL_SIZE_X = POST_PROCESSING ? SCREEN_PIXEL_SIZE.x : TEXTURE_PIXEL_SIZE.x;
	float PIXEL_SIZE_Y = POST_PROCESSING ? SCREEN_PIXEL_SIZE.y : TEXTURE_PIXEL_SIZE.y;
	// Size of the canvas in pixels. (ex 320x180)
	int SIZE_IN_PIXELS_X = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_X : _SIZE_IN_PIXELS_X;
	int SIZE_IN_PIXELS_Y = POST_PROCESSING ? _SCREEN_SIZE_IN_PIXELS_Y : _SIZE_IN_PIXELS_Y;
	// The specific XY coordinates of the current pixel.
	int X = POST_PROCESSING ? _SCREEN_PIXEL_X : _PIXEL_X;
	int Y = POST_PROCESSING ? _SCREEN_PIXEL_Y : _PIXEL_Y;
	// UV coordinates of the current pixel.
	vec2 MUV = POST_PROCESSING ? SCREEN_UV : UV;
	// ---
	
	
	// DISPLACE & PAN
	vec2 adjUV = vec2(0, 0); // WARNING - Use this instead of UV below, otherwise effects break with panning & displace
	
	float displaceUVX = MUV.x + (SCREEN_PIXEL_SIZE.x * float(displace_x));
	float displaceUVY = MUV.y + (SCREEN_PIXEL_SIZE.y * float(displace_y));
	if (displace_repeat) {
		adjUV = mod(vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed, 1.00000);
	} else {
		adjUV = vec2(displaceUVX, displaceUVY) + TIME * auto_pan_speed;
	}
	
	// $HACK$ doing this as a ternary breaks the preview, for some reason
	if (POST_PROCESSING) 
		COLOR = texture(SCREEN_TEXTURE, adjUV);
	else 
		COLOR = texture(TEXTURE, adjUV);
	
	// EXCLUDE COLORS
	bool is_exclude_color = use_exclude_colors && (vec3eq(COLOR.rgb, exclude_color1) || vec3eq(COLOR.rgb, exclude_color2) || vec3eq(COLOR.rgb, exclude_color3) || vec3eq(COLOR.rgb, exclude_color4));
	
	// RECOLOR
	if (vec3eq(COLOR.rgb, replace_color1)) 
		COLOR.rgb = replace_with_color1;
	if (vec3eq(COLOR.rgb, replace_color2)) 
		COLOR.rgb = replace_with_color2;
	if (vec3eq(COLOR.rgb, replace_color3)) 
		COLOR.rgb = replace_with_color3;
	if (vec3eq(COLOR.rgb, replace_color4)) 
		COLOR.rgb = replace_with_color4;
	if (vec3eq(COLOR.rgb, replace_color5)) 
		COLOR.rgb = replace_with_color5;
	if (vec3eq(COLOR.rgb, replace_color_outline))
		COLOR.rgb = replace_with_color_outline;
	
	if (vec3eq(COLOR.rgb, auto_replace_color)) {
		vec3 replaced = auto_replace_color;
		if (auto_replace_replace_original_color)
			replaced = auto_replace_replace_original_color_with;
		COLOR.rgb  = mix(replaced, auto_replace_to_color, abs(vary0to1((TIME-auto_replace_start_time + TIME_OFFSET) * auto_replace_speed)));
	}
	
	// TINT, COLOR CORRECTION, and SCANLINE ignore excluded colors
	if (!is_exclude_color) {
		// TINT
		COLOR.rgb = mix(COLOR.rgb, tint_color, tint_strength);

		// FLASH
		// apply automatic flash
		if (auto_flash_speed != 0.0) {
			float auto_strength = mix(auto_flash_bound1, auto_flash_bound2, abs(vary0to1((TIME-auto_flash_start_time + TIME_OFFSET) * auto_flash_speed)));
			COLOR.rgb = mix(COLOR.rgb, auto_flash_color, auto_strength);
		}
		// apply manual flash
		COLOR.rgb = mix(COLOR.rgb, flash_color, flash_strength);

		// COLOR CORRECTION
		COLOR.r = mix(COLOR.r, 1.0, red_correct);
		COLOR.g = mix(COLOR.g, 1.0, green_correct);
		COLOR.b = mix(COLOR.b, 1.0, blue_correct);
		COLOR.rgb = mix(COLOR.rgb, vec3(0.2126 * COLOR.r + 0.7152 * COLOR.g + 0.0722 * COLOR.b), gray_correct);
		COLOR.rgb = mix(vec3(0.0), COLOR.rgb, brightness_correct);
		COLOR.rgb = mix(vec3(0.5), COLOR.rgb, contrast_correct);
		COLOR.rgb = mix(vec3(dot(vec3(1.0), COLOR.rbg)), COLOR.rgb, saturation_correct);

		// SCANLINE
		// FIX
		if (COLOR.a != 0.0) {
			float l_to_r_pos = !auto_scanline_left_to_right_on ? scanline_left_to_right_position : abs((auto_scanline_left_to_right_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_left_to_right_start_time + TIME_OFFSET, auto_scanline_left_to_right_delay + auto_scanline_left_to_right_scan_duration), 0.0, auto_scanline_left_to_right_scan_duration)/auto_scanline_left_to_right_scan_duration)));
			float t_to_b_pos = !auto_scanline_top_to_bottom_on ? scanline_top_to_bottom_position : abs((auto_scanline_top_to_bottom_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_top_to_bottom_start_time + TIME_OFFSET, auto_scanline_top_to_bottom_delay + auto_scanline_top_to_bottom_scan_duration), 0.0, auto_scanline_top_to_bottom_scan_duration)/auto_scanline_top_to_bottom_scan_duration)));
			float tl_to_br_pos = !auto_scanline_topleft_to_bottomright_on ? scanline_topleft_to_bottomright_position : abs((auto_scanline_topleft_to_bottomright_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topleft_to_bottomright_start_time + TIME_OFFSET, auto_scanline_topleft_to_bottomright_delay + auto_scanline_topleft_to_bottomright_scan_duration), 0.0, auto_scanline_topleft_to_bottomright_scan_duration)/auto_scanline_topleft_to_bottomright_scan_duration)));
			float tr_to_bl_pos = !auto_scanline_topright_to_bottomleft_on ? scanline_topright_to_bottomleft_position : abs((auto_scanline_topright_to_bottomleft_reverse ? 1.0 : 0.0) - mix(0.0, 1.0, float(clamp(mod(TIME - auto_scanline_topright_to_bottomleft_start_time + TIME_OFFSET, auto_scanline_topright_to_bottomleft_delay + auto_scanline_topright_to_bottomleft_scan_duration), 0.0, auto_scanline_topright_to_bottomleft_scan_duration)/auto_scanline_topright_to_bottomleft_scan_duration)));

			if (X == int(floor(l_to_r_pos / float(PIXEL_SIZE_X))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (Y == int(floor(t_to_b_pos / float(PIXEL_SIZE_Y))))
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			int scanline_target_tlbr = int(floor(tl_to_br_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y)));
			int scanline_target_trbl = int(floor(tr_to_bl_pos * float(SIZE_IN_PIXELS_X + SIZE_IN_PIXELS_Y))) - SIZE_IN_PIXELS_Y;
			if (X+Y == scanline_target_tlbr)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
			if (X-Y == scanline_target_trbl)
				COLOR.rgb = mix(COLOR.rgb, scanline_color, scanline_strength);
		}
	}

	// GLOW
	if (glow_thickness != 0) {
		vec2 outline_size = TEXTURE_PIXEL_SIZE * float(glow_thickness);
		float outline = 0.0;
		for (int i = 0; i < HORIZONTAL_VERTICAL_OFFSETS.length(); i++) {
			outline += texture(TEXTURE, adjUV + outline_size * HORIZONTAL_VERTICAL_OFFSETS[i]).a;
		}
		if (glow_diagonals) {
			for (int i = 0; i < DIAGONAL_OUTLINE_OFFSETS.length(); i++) {
				outline += texture(TEXTURE, adjUV + outline_size * DIAGONAL_OUTLINE_OFFSETS[i]).a;
			}
		}
		outline = min(outline, 1.0);
		// this is a bit of a coding $HACK$ to make auto_glow_bound do nothing if auto_glow_speed is 0, but it definitely works
		float alp = auto_glow_speed == 0.0 ? 1.0 : mix(auto_glow_bound, glow_color.a, vary0to1((TIME - auto_glow_start_time + TIME_OFFSET) * auto_glow_speed));
		COLOR = mix(COLOR, glow_color * alp, outline - COLOR.a);
	}

	// DISINTEGRATE
	if (!is_exclude_color && COLOR.a != 0.0) {
		vec2 s = adjUV * vec2(float(disintegrate_seed));
		s *= auto_disintegrate_random_seed_speed != 0.0 ? float(int(TIME / mix(1.0, 0.001, auto_disintegrate_random_seed_speed))) : 1.0;
		float r = random(s);
		if (r < disintegrate_strength) {
			float r_alpha = randf_range(s, disintegrate_alpha_bound1, disintegrate_alpha_bound2);
			COLOR.rgb = mix(COLOR.rgb, disintegrate_color, r_alpha);
			if (!disintegrate_as_static)
				COLOR.a = r_alpha;
		}
	}

	// FOG
	if (fog_enabled) {
		vec2 fog_uv = MUV + fog_speed * TIME;
		float noise_alpha = texture(fog_noise_texture, fog_uv).r;
		// Convert noise from (0.0, 1.0) to (-1.0, 1.0)
		float fog = clamp((noise_alpha * 2.0 - 1.0) + (fog_density * 2.0), 0.0, 1.0);
		COLOR.a *= fog * fog_opacity;
	}

	// COLORLINES	
	if (!is_exclude_color) {
		if (X % vertical_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, vertical_colorline_color, vertical_colorline_strength);
		}
		if (Y % horizontal_colorline_spacing == 0) {
			COLOR.rgb = mix(COLOR.rgb, horizontal_colorline_color, horizontal_colorline_strength);
		}
	}

	// CHECKER
	if (!is_exclude_color) {	
		if (X/checker_x_size % checker_x_pattern != Y/checker_y_size % checker_y_pattern) {
			float pixel_darkness = (3.0 - (COLOR.r + COLOR.g + COLOR.b)) * checker_contrast_ratio; // calculates 0.0 to 1.0 where 1.0 is pure black and 0.0 is pure white
			vec3 cbcolor = mix(checker_color.rgb, vec3(0.0), pixel_darkness * checker_contrast_amount);
			COLOR.rgb = mix(COLOR.rgb, cbcolor, checker_strength);
		}
	}

	// MOUSELIGHT
	if (mouselight_on && (!mouselight_checker || X % 2 == Y % 2)) {
		float mouse_with_flicker = mix(auto_mouselight_flicker_bound, float(mouselight_size), vary0to1(TIME * auto_mouselight_flicker_speed));
		float dist_from_mouse = sqrt(pow(float(_SCREEN_PIXEL_X - int(MOUSE.x)), 2.0) + pow(float(_SCREEN_PIXEL_Y - int(MOUSE.y)), 2.0));
		if (dist_from_mouse <= float(mouse_with_flicker)) {
			//todo - make softening with distance optional as uniform
			float distance_mod = clamp((mouse_with_flicker - dist_from_mouse) / mouse_with_flicker, 0.0, 1.0);
			COLOR.rgb = mix(COLOR.rgb, mouselight_color, distance_mod * mouselight_strength);
		}
	}

	// CUT
	if (MUV.x < cut_left)
		COLOR.a = 0.0;
	if (MUV.x > 1.0-cut_right)
		COLOR.a = 0.0;
	if (MUV.y < cut_top)
		COLOR.a = 0.0;
	if (MUV.y > 1.0-cut_bottom)
		COLOR.a = 0.0;

	// VIGNETTE
	if (vignette_on && ((!vignette_ignore_transparent || COLOR.a != 0.0)) && !is_exclude_color) {
		float x = abs(adjUV.x-.5)*2.0;
		float y = abs(adjUV.y-.5)*2.0;
		float v = (sqrt((x*x)+(y*y))/vignette_radius);
		COLOR = mix(COLOR, vec4(vignette_color.r, vignette_color.g, vignette_color.b, 1.0), v);
	}

	// TRANSPARENCY
	if (COLOR.a != 0.0) {
		COLOR.a = mix(COLOR.a * transparency, auto_flicker_bound, vary0to1((TIME-auto_flicker_start_time + TIME_OFFSET) * auto_flicker_speed));
	}
	
	} //end if disable
}

void vertex()
{
	
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_r6c70"]
shader = SubResource("Shader_l6nco")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0.164706, 0.0196078, 0.505882, 1)
shader_parameter/tint_strength = 1.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(0.113725, 0.0117647, 0.407843, 1)
shader_parameter/auto_flash_speed = 3.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 0.75
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(-0.02, 0)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 8.0
shader_parameter/auto_mouselight_flicker_bound = 10.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 0.1
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[sub_resource type="ShaderMaterial" id="ShaderMaterial_1biib"]
shader = ExtResource("7_aonp5")
shader_parameter/POST_PROCESSING = false
shader_parameter/MOUSE = Vector2(20, 20)
shader_parameter/DISABLE = false
shader_parameter/use_exclude_colors = true
shader_parameter/exclude_color1 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color2 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color3 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color4 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color5 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color6 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color7 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/exclude_color8 = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/displace_x = 0
shader_parameter/displace_y = 0
shader_parameter/displace_repeat = true
shader_parameter/auto_pan_speed = Vector2(0, 0)
shader_parameter/replace_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color1 = Color(0, 0, 0, 1)
shader_parameter/replace_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color2 = Color(0, 0, 0, 1)
shader_parameter/replace_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color3 = Color(0, 0, 0, 1)
shader_parameter/replace_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color4 = Color(0, 0, 0, 1)
shader_parameter/replace_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_with_color5 = Color(0, 0, 0, 1)
shader_parameter/replace_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/replace_with_color_outline = Color(0.0784314, 0.0627451, 0.0745098, 1)
shader_parameter/auto_replace_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_replace_original_color = false
shader_parameter/auto_replace_replace_original_color_with = Color(0, 0, 0, 1)
shader_parameter/auto_replace_to_color = Color(0, 0, 0, 1)
shader_parameter/auto_replace_speed = 0.0
shader_parameter/auto_replace_start_time = 0.0
shader_parameter/tint_color = Color(0, 0, 0, 1)
shader_parameter/tint_strength = 1.0
shader_parameter/flash_color = Color(1, 1, 1, 1)
shader_parameter/flash_strength = 0.0
shader_parameter/auto_flash_color = Color(1, 1, 1, 1)
shader_parameter/auto_flash_speed = 0.0
shader_parameter/auto_flash_bound1 = 0.0
shader_parameter/auto_flash_bound2 = 1.0
shader_parameter/auto_flash_start_time = 0.0
shader_parameter/red_correct = 0.0
shader_parameter/green_correct = 0.0
shader_parameter/blue_correct = 0.0
shader_parameter/gray_correct = 0.0
shader_parameter/brightness_correct = 1.0
shader_parameter/contrast_correct = 1.0
shader_parameter/saturation_correct = 1.0
shader_parameter/scanline_color = Color(0.98, 0.69, 0.23, 1)
shader_parameter/scanline_strength = 1.0
shader_parameter/scanline_left_to_right_position = -0.001
shader_parameter/scanline_top_to_bottom_position = -0.001
shader_parameter/scanline_topleft_to_bottomright_position = -0.001
shader_parameter/scanline_topright_to_bottomleft_position = -0.001
shader_parameter/auto_scanline_left_to_right_on = false
shader_parameter/auto_scanline_left_to_right_reverse = false
shader_parameter/auto_scanline_left_to_right_start_time = 0.0
shader_parameter/auto_scanline_left_to_right_scan_duration = 0.5
shader_parameter/auto_scanline_left_to_right_delay = 1.0
shader_parameter/auto_scanline_top_to_bottom_on = false
shader_parameter/auto_scanline_top_to_bottom_reverse = false
shader_parameter/auto_scanline_top_to_bottom_start_time = 0.0
shader_parameter/auto_scanline_top_to_bottom_scan_duration = 0.5
shader_parameter/auto_scanline_top_to_bottom_delay = 1.0
shader_parameter/auto_scanline_topleft_to_bottomright_on = false
shader_parameter/auto_scanline_topleft_to_bottomright_reverse = false
shader_parameter/auto_scanline_topleft_to_bottomright_start_time = 0.0
shader_parameter/auto_scanline_topleft_to_bottomright_scan_duration = 0.5
shader_parameter/auto_scanline_topleft_to_bottomright_delay = 1.0
shader_parameter/auto_scanline_topright_to_bottomleft_on = false
shader_parameter/auto_scanline_topright_to_bottomleft_reverse = false
shader_parameter/auto_scanline_topright_to_bottomleft_start_time = 0.0
shader_parameter/auto_scanline_topright_to_bottomleft_scan_duration = 0.5
shader_parameter/auto_scanline_topright_to_bottomleft_delay = 1.0
shader_parameter/glow_color = Color(1, 1, 1, 1)
shader_parameter/glow_thickness = 0
shader_parameter/glow_diagonals = false
shader_parameter/auto_glow_speed = 0.0
shader_parameter/auto_glow_bound = 0.75
shader_parameter/auto_glow_start_time = 0.0
shader_parameter/disintegrate_seed = 1
shader_parameter/disintegrate_color = Color(0, 0, 0, 1)
shader_parameter/disintegrate_strength = 0.0
shader_parameter/disintegrate_alpha_bound1 = 0.0
shader_parameter/disintegrate_alpha_bound2 = 0.0
shader_parameter/disintegrate_as_static = false
shader_parameter/auto_disintegrate_random_seed_speed = 0.0
shader_parameter/fog_enabled = false
shader_parameter/fog_opacity = 0.5
shader_parameter/fog_density = 0.25
shader_parameter/fog_speed = Vector2(-0.02, 0)
shader_parameter/vertical_colorline_color = Color(1, 1, 1, 1)
shader_parameter/vertical_colorline_spacing = 2
shader_parameter/vertical_colorline_strength = 0.0
shader_parameter/horizontal_colorline_color = Color(1, 1, 1, 1)
shader_parameter/horizontal_colorline_spacing = 2
shader_parameter/horizontal_colorline_strength = 0.0
shader_parameter/checker_color = Color(0.2, 0.2, 0.2, 1)
shader_parameter/checker_strength = 0.0
shader_parameter/checker_x_size = 1
shader_parameter/checker_y_size = 1
shader_parameter/checker_x_pattern = 2
shader_parameter/checker_y_pattern = 2
shader_parameter/checker_contrast_amount = 1.0
shader_parameter/checker_contrast_ratio = 0.5
shader_parameter/mouselight_on = false
shader_parameter/mouselight_color = Color(1, 1, 1, 1)
shader_parameter/mouselight_strength = 0.5
shader_parameter/mouselight_size = 8
shader_parameter/mouselight_soften_edges = true
shader_parameter/mouselight_checker = false
shader_parameter/auto_mouselight_flicker_speed = 8.0
shader_parameter/auto_mouselight_flicker_bound = 10.0
shader_parameter/cut_left = 0.0
shader_parameter/cut_right = 0.0
shader_parameter/cut_top = 0.0
shader_parameter/cut_bottom = 0.0
shader_parameter/vignette_on = false
shader_parameter/vignette_ignore_transparent = false
shader_parameter/vignette_color = Color(0, 0, 0, 1)
shader_parameter/vignette_radius = 1.0
shader_parameter/transparency = 0.0
shader_parameter/auto_flicker_speed = 0.0
shader_parameter/auto_flicker_bound = 0.0
shader_parameter/auto_flicker_start_time = 0.0

[node name="Game" type="Node2D"]
script = ExtResource("1_2km4d")

[node name="TableBG" type="Sprite2D" parent="."]
material = ExtResource("2_82tsr")
texture = ExtResource("3_uvdwv")
centered = false

[node name="RiverRight" type="Node2D" parent="."]
script = ExtResource("3_icqna")

[node name="Purple" type="Sprite2D" parent="RiverRight"]
material = ExtResource("3_lg24x")
position = Vector2(318, 0)
texture = ExtResource("4_hxf6a")
centered = false
flip_h = true

[node name="FX" parent="RiverRight/Purple" instance=ExtResource("6_gfndp")]

[node name="Green" type="Sprite2D" parent="RiverRight"]
material = SubResource("ShaderMaterial_aonxi")
position = Vector2(318, 0)
texture = ExtResource("6_df67t")
centered = false
flip_h = true

[node name="FX" parent="RiverRight/Green" instance=ExtResource("6_gfndp")]

[node name="Red" type="Sprite2D" parent="RiverRight"]
material = SubResource("ShaderMaterial_egygr")
position = Vector2(318, 0)
texture = ExtResource("7_5tpvh")
centered = false
flip_h = true

[node name="FX" parent="RiverRight/Red" instance=ExtResource("6_gfndp")]

[node name="RiverLeft" type="Node2D" parent="."]
script = ExtResource("3_icqna")

[node name="Purple" type="Sprite2D" parent="RiverLeft"]
material = SubResource("ShaderMaterial_4n7hr")
texture = ExtResource("4_hxf6a")
centered = false

[node name="FX" parent="RiverLeft/Purple" instance=ExtResource("6_gfndp")]
root_node = NodePath("../..")

[node name="Green" type="Sprite2D" parent="RiverLeft"]
material = SubResource("ShaderMaterial_tw3c5")
texture = ExtResource("6_df67t")
centered = false

[node name="FX" parent="RiverLeft/Green" instance=ExtResource("6_gfndp")]

[node name="Red" type="Sprite2D" parent="RiverLeft"]
material = SubResource("ShaderMaterial_vtiq0")
texture = ExtResource("7_5tpvh")
centered = false

[node name="FX" parent="RiverLeft/Red" instance=ExtResource("6_gfndp")]

[node name="Table" type="Node2D" parent="."]

[node name="LivesLabel" type="Label" parent="Table"]
texture_filter = 1
material = SubResource("ShaderMaterial_eloju")
offset_left = -1.0
offset_top = 78.0
offset_right = 67.0
offset_bottom = 97.0
theme_override_fonts/font = ExtResource("14_om374")
theme_override_font_sizes/font_size = 16
text = "3"
horizontal_alignment = 1
script = ExtResource("15_wj7tb")

[node name="FX" type="AnimationPlayer" parent="Table/LivesLabel"]
root_node = NodePath("../../..")
script = ExtResource("7_4br5g")

[node name="SoulsLabel" type="Label" parent="Table"]
texture_filter = 1
material = SubResource("ShaderMaterial_6w1vx")
offset_left = 252.0
offset_top = 79.0
offset_right = 320.0
offset_bottom = 98.0
theme_override_fonts/font = ExtResource("14_om374")
text = "5"
horizontal_alignment = 1
script = ExtResource("16_ee6yk")

[node name="FX" type="AnimationPlayer" parent="Table/SoulsLabel"]
root_node = NodePath("../../..")
script = ExtResource("7_4br5g")

[node name="PassiveBoosts" type="GridContainer" parent="Table"]
offset_left = 3.0
offset_top = 2.0
offset_right = 83.0
offset_bottom = 43.0
theme_override_constants/h_separation = 0
theme_override_constants/v_separation = 0
columns = 2

[node name="FlameLabel" type="RichTextLabel" parent="Table/PassiveBoosts"]
material = SubResource("ShaderMaterial_exojv")
custom_minimum_size = Vector2(40, 14)
layout_mode = 2
mouse_filter = 2
bbcode_enabled = true
text = "[center][img=10x13]res://assets/icons/coin/prometheus_icon.png[/img]+25%[/center]"
scroll_active = false
script = ExtResource("15_nixm5")

[node name="FX" parent="Table/PassiveBoosts/FlameLabel" instance=ExtResource("6_gfndp")]

[node name="TooltipEmitter" type="Control" parent="Table/PassiveBoosts/FlameLabel"]
anchors_preset = 0
offset_right = 40.0
offset_bottom = 14.0
script = ExtResource("16_1vi63")
_tooltip = "All coins will land on (HEADS)
+(FLAME_INCREASE)% more often.
"

[node name="IgniteLabel" type="RichTextLabel" parent="Table/PassiveBoosts"]
material = SubResource("ShaderMaterial_hx7il")
custom_minimum_size = Vector2(40, 14)
layout_mode = 2
mouse_filter = 2
bbcode_enabled = true
text = "[center][img=10x13]res://assets/icons/status/ignite_icon.png[/img]+2[/center]"
scroll_active = false
script = ExtResource("17_msny5")

[node name="FX" parent="Table/PassiveBoosts/IgniteLabel" instance=ExtResource("6_gfndp")]

[node name="TooltipEmitter" type="Control" parent="Table/PassiveBoosts/IgniteLabel"]
anchors_preset = 0
offset_right = 40.0
offset_bottom = 14.0
script = ExtResource("16_1vi63")
_tooltip = "(IGNITE) damage is increased 
by (IGNITE_INCREASE)."

[node name="VoyageMap" parent="Table" instance=ExtResource("18_vo2di")]
position = Vector2(61, 19)

[node name="LifeFragments" type="Node2D" parent="Table"]

[node name="SoulFragments" type="Node2D" parent="Table"]

[node name="ShopMat" type="Sprite2D" parent="Table"]
material = SubResource("ShaderMaterial_kheqr")
position = Vector2(60, 43)
texture = ExtResource("21_brubq")
centered = false
script = ExtResource("16_i4s2h")

[node name="FX" parent="Table/ShopMat" instance=ExtResource("6_gfndp")]

[node name="CharonHandRight" parent="Table" instance=ExtResource("16_32esb")]
position = Vector2(185, -40)
HAND_TYPE = 1

[node name="CharonHandLeft" parent="Table" instance=ExtResource("16_32esb")]
position = Vector2(73, -40)

[node name="CharonObolRow" parent="Table" instance=ExtResource("19_ym3ga")]
offset_top = 111.0
offset_right = 320.0
offset_bottom = 155.0

[node name="EnemyRow" type="Node2D" parent="Table"]
position = Vector2(0, 5)
script = ExtResource("24_cds23")

[node name="CoinRow" parent="Table/EnemyRow" instance=ExtResource("19_ym3ga")]
offset_top = 56.0
offset_right = 320.0
offset_bottom = 100.0

[node name="CoinRow" parent="Table" instance=ExtResource("19_ym3ga")]
z_index = 2
offset_top = 111.0
offset_right = 320.0
offset_bottom = 155.0

[node name="Shop" type="Node2D" parent="Table"]
script = ExtResource("20_xqqdj")

[node name="ShopRow" parent="Table/Shop" instance=ExtResource("19_ym3ga")]
offset_top = 49.0
offset_right = 320.0
offset_bottom = 93.0

[node name="Arrows" type="Node2D" parent="Table"]

[node name="PatronToken" parent="Table" instance=ExtResource("24_k7xdm")]
offset_left = 245.0
offset_top = 150.0
offset_right = 289.0
offset_bottom = 178.0

[node name="UI" type="Node2D" parent="."]
z_index = 2000

[node name="MapBlocker" type="ColorRect" parent="UI"]
visible = false
modulate = Color(1, 1, 1, 0)
offset_right = 320.0
offset_bottom = 180.0
mouse_filter = 2
color = Color(0, 0, 0, 1)

[node name="LifeBlockerHack" type="ColorRect" parent="UI/MapBlocker"]
layout_mode = 0
offset_right = 59.0
offset_bottom = 97.0
color = Color(1, 1, 1, 0)

[node name="ArrowBlockerHack" type="ColorRect" parent="UI/MapBlocker"]
layout_mode = 0
offset_left = 1.0
offset_top = 137.0
offset_right = 106.0
offset_bottom = 180.0
color = Color(0.0235294, 0.145098, 0.168627, 0)

[node name="SoulBlockerHack" type="ColorRect" parent="UI/MapBlocker"]
layout_mode = 0
offset_left = 261.0
offset_right = 320.0
offset_bottom = 97.0
color = Color(1, 1, 1, 0)

[node name="DialogueSystem" parent="UI" instance=ExtResource("4_sixhk")]
z_index = 100
position = Vector2(0, 1)
text_color = Color(0.913725, 0.619608, 0.811765, 1)
background_color = Color(0.027451, 0.0196078, 0.027451, 1)
border_color = Color(0.909804, 0.415686, 0.45098, 1)
flash_color = Color(0.960784, 0.643137, 0.65098, 1)
textbox_effects_while_waiting = true
textbox_float = true

[node name="PlayerTextboxes" type="HBoxContainer" parent="UI"]
z_index = 100
offset_left = 5.0
offset_top = 160.0
offset_right = 315.0
offset_bottom = 176.0
pivot_offset = Vector2(154, 8)
alignment = 1
script = ExtResource("5_6g64w")

[node name="TossButton" parent="UI/PlayerTextboxes" instance=ExtResource("5_703wq")]
material = SubResource("ShaderMaterial_7kp4x")
layout_mode = 2
script = ExtResource("6_rf73a")
default_text = "Toss"

[node name="AcceptButton" parent="UI/PlayerTextboxes" instance=ExtResource("5_703wq")]
material = SubResource("ShaderMaterial_gomxl")
layout_mode = 2
script = ExtResource("7_2acd8")
default_text = "Accept Payoff"

[node name="ShopContinueButton" parent="UI/PlayerTextboxes" instance=ExtResource("5_703wq")]
visible = false
material = SubResource("ShaderMaterial_u7wvf")
layout_mode = 2
script = ExtResource("8_leu43")
default_text = "Leave Shop"

[node name="ShopRerollButton" parent="UI/PlayerTextboxes" instance=ExtResource("5_703wq")]
visible = false
material = SubResource("ShaderMaterial_i88l0")
layout_mode = 2
script = ExtResource("9_cd2hg")
default_text = "Reroll"

[node name="EndRoundButton" parent="UI/PlayerTextboxes" instance=ExtResource("5_703wq")]
visible = false
material = SubResource("ShaderMaterial_04xvu")
layout_mode = 2
script = ExtResource("9_d50av")
default_text = "End Round"

[node name="DieButton" parent="UI/PlayerTextboxes" instance=ExtResource("5_703wq")]
visible = false
material = SubResource("ShaderMaterial_biei3")
layout_mode = 2
script = ExtResource("10_oe7lm")
default_text = "Die, Forgotten"

[node name="PayTollButton" parent="UI/PlayerTextboxes" instance=ExtResource("5_703wq")]
visible = false
material = SubResource("ShaderMaterial_8gsjf")
layout_mode = 2
script = ExtResource("11_mcnia")
default_text = "Pay Toll"

[node name="VoyageNextRoundButton" parent="UI/PlayerTextboxes" instance=ExtResource("5_703wq")]
visible = false
z_index = 5
material = SubResource("ShaderMaterial_k7ltx")
layout_mode = 2
script = ExtResource("12_dxqog")
default_text = "Begin Next Round"

[node name="BoardButton" parent="UI/PlayerTextboxes" instance=ExtResource("5_703wq")]
visible = false
material = SubResource("ShaderMaterial_uu5uq")
layout_mode = 2
script = ExtResource("13_6rw3p")
default_text = "Board"

[node name="SpeedrunTimer" type="Label" parent="UI"]
modulate = Color(1, 1, 1, 0.196078)
offset_left = 287.0
offset_top = 167.0
offset_right = 322.0
offset_bottom = 183.0
text = "00:00"
horizontal_alignment = 1
script = ExtResource("34_5jlkt")

[node name="InfoView" type="Node2D" parent="UI" node_paths=PackedStringArray("coin_row")]
script = ExtResource("39_25ek7")
coin_row = NodePath("../../Table/CoinRow")

[node name="CoinLimit" type="RichTextLabel" parent="UI/InfoView"]
offset_top = 145.0
offset_right = 320.0
offset_bottom = 160.0
mouse_filter = 2
theme_override_colors/font_outline_color = Color(0, 0, 0, 1)
theme_override_constants/outline_size = 4
bbcode_enabled = true
text = "[center][color=#e12f3b]10/10[img=12x13]res://assets/icons/coin_icon.png[/img][/color][/center]"

[node name="ArrowCount" type="RichTextLabel" parent="UI/InfoView"]
offset_left = -12.0
offset_top = 158.0
offset_right = 105.0
offset_bottom = 173.0
mouse_filter = 2
theme_override_colors/font_outline_color = Color(0, 0, 0, 1)
theme_override_constants/outline_size = 4
bbcode_enabled = true
text = "[center]10/10[img=12x13]res://assets/icons/arrow_icon.png[/img][/center]"

[node name="Points" type="Node2D" parent="."]

[node name="Charon" type="Node2D" parent="Points"]
position = Vector2(160, -44)

[node name="SoulFragmentPile" type="Node2D" parent="Points"]
position = Vector2(277, 33)

[node name="Player" type="Node2D" parent="Points"]
position = Vector2(166.5, 212)

[node name="LifeFragmentPile" type="Node2D" parent="Points"]
position = Vector2(20, 42)

[node name="ArrowPile" type="Node2D" parent="Points"]
position = Vector2(13, 157)

[node name="MapInitial" type="Node2D" parent="Points"]
position = Vector2(123, 0)

[node name="MapHidden" type="Node2D" parent="Points"]
position = Vector2(236, 14)

[node name="MapShown" type="Node2D" parent="Points"]
position = Vector2(61, 19)

[node name="Camera" type="Camera2D" parent="."]
anchor_mode = 0
limit_left = 0
limit_top = 0
limit_right = 320
limit_bottom = 180

[node name="Embers" type="GPUParticles2D" parent="."]
modulate = Color(0.737255, 0.290196, 0.607843, 1)
position = Vector2(-27, 86)
amount = 16
process_material = SubResource("ParticleProcessMaterial_t5ya3")
lifetime = 5.0
preprocess = 5.0
trail_lifetime = 3.5

[node name="TrialEmbers" type="GPUParticles2D" parent="."]
modulate = Color(0.737255, 0.290196, 0.607843, 1)
position = Vector2(-27, 86)
amount = 64
process_material = SubResource("ParticleProcessMaterial_r1e2v")
lifetime = 5.0
preprocess = 5.0
trail_lifetime = 3.5

[node name="MaliceDust" type="GPUParticles2D" parent="."]
position = Vector2(159, -15)
emitting = false
amount = 30
process_material = SubResource("ParticleProcessMaterial_m5kuv")
texture = ExtResource("36_l5qg4")
lifetime = 2.0

[node name="MaliceDustRed" type="GPUParticles2D" parent="."]
position = Vector2(159, -15)
emitting = false
amount = 20
process_material = SubResource("ParticleProcessMaterial_84yqa")
texture = ExtResource("36_l5qg4")
lifetime = 2.0

[node name="DeathSpiral" type="GPUParticles2D" parent="."]
visible = false
position = Vector2(155, 66)
amount = 100
process_material = SubResource("ParticleProcessMaterial_lkb7x")
texture = ExtResource("36_lon5y")
lifetime = 0.25
trail_lifetime = 3.5

[node name="Fog" type="ColorRect" parent="."]
z_index = 1000
material = SubResource("ShaderMaterial_a7o28")
offset_right = 320.0
offset_bottom = 180.0
mouse_filter = 2

[node name="FX" type="AnimationPlayer" parent="Fog"]
script = ExtResource("7_4br5g")

[node name="FogBlue" type="ColorRect" parent="."]
z_index = 1000
material = SubResource("ShaderMaterial_ruuci")
offset_right = 320.0
offset_bottom = 180.0
mouse_filter = 2

[node name="FX" type="AnimationPlayer" parent="FogBlue"]
script = ExtResource("7_4br5g")

[node name="CharonFog" type="ColorRect" parent="."]
visible = false
z_index = 1000
material = SubResource("ShaderMaterial_503b8")
offset_right = 320.0
offset_bottom = 180.0
mouse_filter = 2

[node name="FX" parent="CharonFog" instance=ExtResource("6_gfndp")]

[node name="TrialTint" type="ColorRect" parent="."]
visible = false
z_index = 1000
material = SubResource("ShaderMaterial_6ippc")
offset_right = 320.0
offset_bottom = 180.0
mouse_filter = 2

[node name="FX" parent="TrialTint" instance=ExtResource("6_gfndp")]

[node name="NemesisTint" type="ColorRect" parent="."]
visible = false
z_index = 1000
material = SubResource("ShaderMaterial_e7dsc")
offset_right = 320.0
offset_bottom = 180.0
mouse_filter = 2

[node name="FX" parent="NemesisTint" instance=ExtResource("6_gfndp")]

[node name="CharonTint" type="ColorRect" parent="."]
visible = false
z_index = 1000
material = SubResource("ShaderMaterial_r6c70")
offset_right = 320.0
offset_bottom = 180.0
mouse_filter = 2

[node name="FX" parent="CharonTint" instance=ExtResource("6_gfndp")]

[node name="TutorialFade" type="ColorRect" parent="."]
z_index = 1000
material = SubResource("ShaderMaterial_1biib")
offset_left = 3.0
offset_top = 2.0
offset_right = 323.0
offset_bottom = 182.0
mouse_filter = 2

[node name="FX" type="AnimationPlayer" parent="TutorialFade"]
script = ExtResource("7_4br5g")

[connection signal="clicked" from="Table/VoyageMap" to="." method="_on_voyage_map_clicked"]
[connection signal="closed" from="Table/VoyageMap" to="." method="_on_voyage_map_closed"]
[connection signal="coin_purchased" from="Table/Shop" to="." method="_on_shop_coin_purchased"]
[connection signal="clicked" from="UI/PlayerTextboxes/TossButton" to="." method="_on_toss_button_clicked"]
[connection signal="clicked" from="UI/PlayerTextboxes/AcceptButton" to="." method="_on_accept_button_pressed"]
[connection signal="clicked" from="UI/PlayerTextboxes/ShopContinueButton" to="." method="_on_continue_button_pressed"]
[connection signal="clicked" from="UI/PlayerTextboxes/ShopRerollButton" to="." method="_on_shop_reroll_button_clicked"]
[connection signal="clicked" from="UI/PlayerTextboxes/EndRoundButton" to="." method="_on_end_round_button_pressed"]
[connection signal="clicked" from="UI/PlayerTextboxes/DieButton" to="." method="_on_die_button_clicked"]
[connection signal="clicked" from="UI/PlayerTextboxes/PayTollButton" to="." method="_on_pay_toll_button_clicked"]
[connection signal="clicked" from="UI/PlayerTextboxes/VoyageNextRoundButton" to="." method="_on_voyage_continue_button_clicked"]
[connection signal="clicked" from="UI/PlayerTextboxes/BoardButton" to="." method="_on_board_button_clicked"]

[editable path="UI/PlayerTextboxes/AcceptButton"]
[editable path="UI/PlayerTextboxes/ShopContinueButton"]
[editable path="UI/PlayerTextboxes/ShopRerollButton"]
[editable path="UI/PlayerTextboxes/EndRoundButton"]
[editable path="UI/PlayerTextboxes/DieButton"]
[editable path="UI/PlayerTextboxes/PayTollButton"]
[editable path="UI/PlayerTextboxes/VoyageNextRoundButton"]
[editable path="UI/PlayerTextboxes/BoardButton"]
